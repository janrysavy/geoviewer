var hs=Object.defineProperty;var fs=(e,t,n)=>t in e?hs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var j=(e,t,n)=>fs(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const c of i.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&o(c)}).observe(document,{childList:!0,subtree:!0});function n(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerPolicy&&(i.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?i.credentials="include":a.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function o(a){if(a.ep)return;a.ep=!0;const i=n(a);fetch(a.href,i)}})();async function us(e,t){var c,r,l,d;if(!navigator.gpu){const h=new Error("WebGPU is not supported by this browser.");throw(c=t==null?void 0:t.fail)==null||c.call(t,"navigator.gpu",h),h}const n=(t==null?void 0:t.call("canvas.getContext('webgpu')",()=>e.getContext("webgpu")))??e.getContext("webgpu");if(!n){const h=new Error("Failed to acquire WebGPU context.");throw(r=t==null?void 0:t.fail)==null||r.call(t,"canvas.getContext('webgpu')",h),h}const o=(t?await t.callAsync("navigator.gpu.requestAdapter",()=>navigator.gpu.requestAdapter({powerPreference:"high-performance"})):await navigator.gpu.requestAdapter({powerPreference:"high-performance"}))??null;if(!o){const h=new Error("No suitable GPU adapter found.");throw(l=t==null?void 0:t.fail)==null||l.call(t,"navigator.gpu.requestAdapter",h),h}const a=t?await t.callAsync("GPUAdapter.requestDevice",()=>o.requestDevice()):await o.requestDevice();(d=t==null?void 0:t.attachDevice)==null||d.call(t,a);const i=t?t.call("navigator.gpu.getPreferredCanvasFormat",()=>navigator.gpu.getPreferredCanvasFormat()):navigator.gpu.getPreferredCanvasFormat();return{adapter:o,device:a,context:n,format:i}}class ps{constructor(t){j(this,"failed",!1);j(this,"attached",!1);this.reportFailure=t}hasFailed(){return this.failed}fail(t,n,o){this.failed||(this.failed=!0,this.reportFailure({operation:t,error:n,hint:o}))}call(t,n){if(this.failed)throw new Error("WebGPU is in a failed state.");try{return n()}catch(o){throw this.fail(t,o),o}}async callAsync(t,n){if(this.failed)throw new Error("WebGPU is in a failed state.");try{return await n()}catch(o){throw this.fail(t,o),o}}attachDevice(t){this.attached||(this.attached=!0,t.addEventListener("uncapturederror",n=>{this.fail("GPUDevice.uncapturederror",n.error)}),t.lost.then(n=>{this.fail("GPUDevice.lost",new Error(n.message||"The GPU device was lost."),`reason=${n.reason}`)}))}}var sn=1e-6,ot=typeof Float32Array<"u"?Float32Array:Array,ms="zyx";function gs(){var e=new ot(9);return ot!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function Qe(){var e=new ot(16);return ot!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function Uo(e){var t=new ot(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function wn(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function hi(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function xs(e,t){var n=t[0],o=t[1],a=t[2],i=t[3],c=t[4],r=t[5],l=t[6],d=t[7],h=t[8],p=t[9],f=t[10],m=t[11],y=t[12],b=t[13],v=t[14],g=t[15],A=n*r-o*c,M=n*l-a*c,I=n*d-i*c,x=o*l-a*r,P=o*d-i*r,C=a*d-i*l,L=h*b-p*y,w=h*v-f*y,F=h*g-m*y,N=p*v-f*b,D=p*g-m*b,U=f*g-m*v,O=A*U-M*D+I*N+x*F-P*w+C*L;return O?(O=1/O,e[0]=(r*U-l*D+d*N)*O,e[1]=(a*D-o*U-i*N)*O,e[2]=(b*C-v*P+g*x)*O,e[3]=(f*P-p*C-m*x)*O,e[4]=(l*F-c*U-d*w)*O,e[5]=(n*U-a*F+i*w)*O,e[6]=(v*I-y*C-g*M)*O,e[7]=(h*C-f*I+m*M)*O,e[8]=(c*D-r*F+d*L)*O,e[9]=(o*F-n*D-i*L)*O,e[10]=(y*P-b*I+g*A)*O,e[11]=(p*I-h*P-m*A)*O,e[12]=(r*w-c*N-l*L)*O,e[13]=(n*N-o*w+a*L)*O,e[14]=(b*M-y*x-v*A)*O,e[15]=(h*x-p*M+f*A)*O,e):null}function ys(e,t,n){var o=t[0],a=t[1],i=t[2],c=t[3],r=t[4],l=t[5],d=t[6],h=t[7],p=t[8],f=t[9],m=t[10],y=t[11],b=t[12],v=t[13],g=t[14],A=t[15],M=n[0],I=n[1],x=n[2],P=n[3];return e[0]=M*o+I*r+x*p+P*b,e[1]=M*a+I*l+x*f+P*v,e[2]=M*i+I*d+x*m+P*g,e[3]=M*c+I*h+x*y+P*A,M=n[4],I=n[5],x=n[6],P=n[7],e[4]=M*o+I*r+x*p+P*b,e[5]=M*a+I*l+x*f+P*v,e[6]=M*i+I*d+x*m+P*g,e[7]=M*c+I*h+x*y+P*A,M=n[8],I=n[9],x=n[10],P=n[11],e[8]=M*o+I*r+x*p+P*b,e[9]=M*a+I*l+x*f+P*v,e[10]=M*i+I*d+x*m+P*g,e[11]=M*c+I*h+x*y+P*A,M=n[12],I=n[13],x=n[14],P=n[15],e[12]=M*o+I*r+x*p+P*b,e[13]=M*a+I*l+x*f+P*v,e[14]=M*i+I*d+x*m+P*g,e[15]=M*c+I*h+x*y+P*A,e}function Dn(e,t,n,o){var a=t[0],i=t[1],c=t[2],r=t[3],l=a+a,d=i+i,h=c+c,p=a*l,f=a*d,m=a*h,y=i*d,b=i*h,v=c*h,g=r*l,A=r*d,M=r*h,I=o[0],x=o[1],P=o[2];return e[0]=(1-(y+v))*I,e[1]=(f+M)*I,e[2]=(m-A)*I,e[3]=0,e[4]=(f-M)*x,e[5]=(1-(p+v))*x,e[6]=(b+g)*x,e[7]=0,e[8]=(m+A)*P,e[9]=(b-g)*P,e[10]=(1-(p+y))*P,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function bs(e,t,n,o,a){var i=1/Math.tan(t/2);if(e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,a!=null&&a!==1/0){var c=1/(o-a);e[10]=a*c,e[14]=a*o*c}else e[10]=-1,e[14]=-o;return e}function fi(e,t,n,o,a,i,c){var r=1/(t-n),l=1/(o-a),d=1/(i-c);return e[0]=-2*r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=d,e[11]=0,e[12]=(t+n)*r,e[13]=(a+o)*l,e[14]=i*d,e[15]=1,e}function vs(e,t,n,o){var a,i,c,r,l,d,h,p,f,m,y=t[0],b=t[1],v=t[2],g=o[0],A=o[1],M=o[2],I=n[0],x=n[1],P=n[2];return Math.abs(y-I)<sn&&Math.abs(b-x)<sn&&Math.abs(v-P)<sn?hi(e):(h=y-I,p=b-x,f=v-P,m=1/Math.sqrt(h*h+p*p+f*f),h*=m,p*=m,f*=m,a=A*f-M*p,i=M*h-g*f,c=g*p-A*h,m=Math.sqrt(a*a+i*i+c*c),m?(m=1/m,a*=m,i*=m,c*=m):(a=0,i=0,c=0),r=p*c-f*i,l=f*a-h*c,d=h*i-p*a,m=Math.sqrt(r*r+l*l+d*d),m?(m=1/m,r*=m,l*=m,d*=m):(r=0,l=0,d=0),e[0]=a,e[1]=r,e[2]=h,e[3]=0,e[4]=i,e[5]=l,e[6]=p,e[7]=0,e[8]=c,e[9]=d,e[10]=f,e[11]=0,e[12]=-(a*y+i*b+c*v),e[13]=-(r*y+l*b+d*v),e[14]=-(h*y+p*b+f*v),e[15]=1,e)}function Ye(){var e=new ot(3);return ot!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function ui(e){var t=e[0],n=e[1],o=e[2];return Math.sqrt(t*t+n*n+o*o)}function Xe(e,t,n){var o=new ot(3);return o[0]=e,o[1]=t,o[2]=n,o}function pi(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function Ct(e,t,n,o){return e[0]=t,e[1]=n,e[2]=o,e}function Ms(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function Ps(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Vt(e,t,n,o){return e[0]=t[0]+n[0]*o,e[1]=t[1]+n[1]*o,e[2]=t[2]+n[2]*o,e}function ws(e,t){var n=t[0]-e[0],o=t[1]-e[1],a=t[2]-e[2];return Math.sqrt(n*n+o*o+a*a)}function at(e,t){var n=t[0],o=t[1],a=t[2],i=n*n+o*o+a*a;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function mt(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function xt(e,t,n){var o=t[0],a=t[1],i=t[2],c=n[0],r=n[1],l=n[2];return e[0]=a*l-i*r,e[1]=i*c-o*l,e[2]=o*r-a*c,e}var Is=ui;(function(){var e=Ye();return function(t,n,o,a,i,c){var r,l;for(n||(n=3),o||(o=0),a?l=Math.min(a*n+o,t.length):l=t.length,r=o;r<l;r+=n)e[0]=t[r],e[1]=t[r+1],e[2]=t[r+2],i(e,e,c),t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2];return t}})();function Ss(){var e=new ot(4);return ot!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function Ts(e,t){var n=t[0],o=t[1],a=t[2],i=t[3],c=n*n+o*o+a*a+i*i;return c>0&&(c=1/Math.sqrt(c)),e[0]=n*c,e[1]=o*c,e[2]=a*c,e[3]=i*c,e}(function(){var e=Ss();return function(t,n,o,a,i,c){var r,l;for(n||(n=4),o||(o=0),a?l=Math.min(a*n+o,t.length):l=t.length,r=o;r<l;r+=n)e[0]=t[r],e[1]=t[r+1],e[2]=t[r+2],e[3]=t[r+3],i(e,e,c),t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2],t[r+3]=e[3];return t}})();function an(){var e=new ot(4);return ot!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Es(e,t,n){n=n*.5;var o=Math.sin(n);return e[0]=o*t[0],e[1]=o*t[1],e[2]=o*t[2],e[3]=Math.cos(n),e}function In(e,t,n,o){var a=t[0],i=t[1],c=t[2],r=t[3],l=n[0],d=n[1],h=n[2],p=n[3],f,m,y,b,v;return m=a*l+i*d+c*h+r*p,m<0&&(m=-m,l=-l,d=-d,h=-h,p=-p),1-m>sn?(f=Math.acos(m),y=Math.sin(f),b=Math.sin((1-o)*f)/y,v=Math.sin(o*f)/y):(b=1-o,v=o),e[0]=b*a+v*l,e[1]=b*i+v*d,e[2]=b*c+v*h,e[3]=b*r+v*p,e}function As(e,t){var n=t[0]+t[4]+t[8],o;if(n>0)o=Math.sqrt(n+1),e[3]=.5*o,o=.5/o,e[0]=(t[5]-t[7])*o,e[1]=(t[6]-t[2])*o,e[2]=(t[1]-t[3])*o;else{var a=0;t[4]>t[0]&&(a=1),t[8]>t[a*3+a]&&(a=2);var i=(a+1)%3,c=(a+2)%3;o=Math.sqrt(t[a*3+a]-t[i*3+i]-t[c*3+c]+1),e[a]=.5*o,o=.5/o,e[3]=(t[i*3+c]-t[c*3+i])*o,e[i]=(t[i*3+a]+t[a*3+i])*o,e[c]=(t[c*3+a]+t[a*3+c])*o}return e}function Ns(e,t,n,o){var a=arguments.length>4&&arguments[4]!==void 0?arguments[4]:ms,i=Math.PI/360;t*=i,o*=i,n*=i;var c=Math.sin(t),r=Math.cos(t),l=Math.sin(n),d=Math.cos(n),h=Math.sin(o),p=Math.cos(o);switch(a){case"xyz":e[0]=c*d*p+r*l*h,e[1]=r*l*p-c*d*h,e[2]=r*d*h+c*l*p,e[3]=r*d*p-c*l*h;break;case"xzy":e[0]=c*d*p-r*l*h,e[1]=r*l*p-c*d*h,e[2]=r*d*h+c*l*p,e[3]=r*d*p+c*l*h;break;case"yxz":e[0]=c*d*p+r*l*h,e[1]=r*l*p-c*d*h,e[2]=r*d*h-c*l*p,e[3]=r*d*p+c*l*h;break;case"yzx":e[0]=c*d*p+r*l*h,e[1]=r*l*p+c*d*h,e[2]=r*d*h-c*l*p,e[3]=r*d*p-c*l*h;break;case"zxy":e[0]=c*d*p-r*l*h,e[1]=r*l*p+c*d*h,e[2]=r*d*h+c*l*p,e[3]=r*d*p-c*l*h;break;case"zyx":e[0]=c*d*p-r*l*h,e[1]=r*l*p+c*d*h,e[2]=r*d*h-c*l*p,e[3]=r*d*p+c*l*h;break;default:throw new Error("Unknown angle order "+a)}return e}var mi=Ts;(function(){var e=Ye(),t=Xe(1,0,0),n=Xe(0,1,0);return function(o,a,i){var c=mt(a,i);return c<-.999999?(xt(e,t,a),Is(e)<1e-6&&xt(e,n,a),at(e,e),Es(o,e,Math.PI),o):c>.999999?(o[0]=0,o[1]=0,o[2]=0,o[3]=1,o):(xt(e,a,i),o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=1+c,mi(o,o))}})();(function(){var e=an(),t=an();return function(n,o,a,i,c,r){return In(e,o,c,r),In(t,a,i,r),In(n,e,t,2*r*(1-r)),n}})();(function(){var e=gs();return function(t,n,o,a){return e[0]=o[0],e[3]=o[1],e[6]=o[2],e[1]=a[0],e[4]=a[1],e[7]=a[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],mi(t,As(t,e))}})();const Do=-Math.PI/2+.001,Go=Math.PI/2-.001;class Cs{constructor(){j(this,"target",Xe(0,0,0));j(this,"position",Ye());j(this,"yaw",Math.PI*.25);j(this,"pitch",Math.PI*.2);j(this,"distance",6);j(this,"aspect",1);j(this,"fov",45*Math.PI/180);j(this,"near",.1);j(this,"far",1e3);j(this,"orthoScale",4);j(this,"mode","perspective");j(this,"view",Qe());j(this,"proj",Qe());j(this,"viewProj",Qe());j(this,"worldUp",Xe(0,1,0));j(this,"tmpForward",Ye());j(this,"tmpRight",Ye());j(this,"tmpUp",Ye())}setAspect(t){this.aspect=Math.max(1e-4,t)}toggleProjection(){this.mode==="perspective"?(this.orthoScale=this.distance*Math.tan(this.fov*.5),this.mode="axonometric"):(this.distance=this.orthoScale/Math.tan(this.fov*.5),this.mode="perspective")}setAngles(t,n){this.yaw=t,this.pitch=Math.max(Do,Math.min(Go,n))}orbit(t,n,o=.005){this.yaw-=t*o,this.pitch-=n*o,this.pitch=Math.max(Do,Math.min(Go,this.pitch))}zoom(t,n=.001){const o=Math.exp(t*n);this.mode==="perspective"?this.distance=Math.min(200,Math.max(.2,this.distance*o)):this.orthoScale=Math.min(200,Math.max(.2,this.orthoScale*o))}pan(t,n,o){const a=Math.max(1,o),i=this.getPanScale(a);this.updatePosition(),Yn(this.tmpForward,this.target,this.position),at(this.tmpForward,this.tmpForward),xt(this.tmpRight,this.tmpForward,this.worldUp),at(this.tmpRight,this.tmpRight),xt(this.tmpUp,this.tmpRight,this.tmpForward),at(this.tmpUp,this.tmpUp),Vt(this.target,this.target,this.tmpRight,-t*i),Vt(this.target,this.target,this.tmpUp,n*i)}getViewMatrix(){return this.updatePosition(),vs(this.view,this.position,this.target,this.worldUp),this.view}getProjectionMatrix(){if(this.mode==="perspective")bs(this.proj,this.fov,this.aspect,this.near,this.far);else{const t=this.orthoScale,n=t*this.aspect;fi(this.proj,-n,n,-t,t,this.near,this.far)}return this.proj}getViewProjMatrix(){return ys(this.viewProj,this.getProjectionMatrix(),this.getViewMatrix()),this.viewProj}getPosition(){return this.updatePosition(),this.position}fitToBounds(t,n,o=1.2){const a=Xe(t[0],t[1],t[2]),i=Xe(n[0],n[1],n[2]),c=Ye();Ms(c,a,i),Ps(c,c,.5),pi(this.target,c);const r=.5*ws(a,i)*o;if(this.mode==="perspective"){const l=this.fov*.5,d=r/Math.sin(l),h=r/Math.sin(Math.atan(Math.tan(l)*this.aspect));this.distance=Math.max(d,h)}else this.orthoScale=Math.max(.1,r)}updatePosition(){const t=Math.cos(this.pitch),n=Math.sin(this.pitch),o=Math.cos(this.yaw),a=Math.sin(this.yaw);this.position[0]=this.target[0]+this.distance*t*o,this.position[1]=this.target[1]+this.distance*n,this.position[2]=this.target[2]+this.distance*t*a}getPanScale(t){return this.mode==="perspective"?2*this.distance*Math.tan(this.fov*.5)/t:this.orthoScale*2/t}}const zs=1.8;class Fs{constructor(t,n){j(this,"pointerId",null);j(this,"dragMode",null);j(this,"lastX",0);j(this,"lastY",0);j(this,"pointers",new Map);j(this,"lastMidpoint",null);j(this,"lastDistance",null);j(this,"onPointerDown",t=>{if(this.canvas.setPointerCapture(t.pointerId),t.pointerType==="touch"){this.pointers.set(t.pointerId,{x:t.clientX,y:t.clientY}),this.updateTouchGestureState();return}this.pointerId=t.pointerId,this.lastX=t.clientX,this.lastY=t.clientY,this.dragMode=this.getDragMode(t)});j(this,"onPointerMove",t=>{if(t.pointerType==="touch"){const a=this.pointers.get(t.pointerId);if(!a)return;const i={x:t.clientX,y:t.clientY};if(this.pointers.set(t.pointerId,i),this.pointers.size===1){const d=i.x-a.x,h=i.y-a.y;this.camera.orbit(-d,-h);return}const c=this.getTwoTouchPoints();if(!c)return;const r=this.getMidpoint(c[0],c[1]),l=this.getDistance(c[0],c[1]);if(this.lastMidpoint&&this.lastDistance!==null){const d=r.x-this.lastMidpoint.x,h=r.y-this.lastMidpoint.y;this.camera.pan(d,h,this.canvas.clientHeight);const p=l-this.lastDistance;Math.abs(p)>0&&this.camera.zoom(-p)}this.lastMidpoint=r,this.lastDistance=l;return}if(this.pointerId!==t.pointerId||!this.dragMode)return;const n=t.clientX-this.lastX,o=t.clientY-this.lastY;this.dragMode==="orbit"?this.camera.orbit(-n,-o):this.camera.pan(n,o,this.canvas.clientHeight),this.lastX=t.clientX,this.lastY=t.clientY});j(this,"onPointerUp",t=>{if(t.pointerType==="touch"){this.pointers.delete(t.pointerId),this.updateTouchGestureState(),this.canvas.releasePointerCapture(t.pointerId);return}this.pointerId===t.pointerId&&(this.canvas.releasePointerCapture(t.pointerId),this.pointerId=null,this.dragMode=null)});j(this,"onWheel",t=>{t.preventDefault();const n=t.deltaY*zs;this.camera.zoom(n)});j(this,"onKeyDown",t=>{t.code==="KeyP"&&this.camera.toggleProjection()});this.canvas=t,this.camera=n,this.attach()}attach(){this.canvas.addEventListener("pointerdown",this.onPointerDown),this.canvas.addEventListener("pointermove",this.onPointerMove),this.canvas.addEventListener("pointerup",this.onPointerUp),this.canvas.addEventListener("pointercancel",this.onPointerUp),this.canvas.addEventListener("wheel",this.onWheel,{passive:!1}),this.canvas.addEventListener("contextmenu",t=>{t.preventDefault()}),window.addEventListener("keydown",this.onKeyDown)}updateTouchGestureState(){const t=this.getTwoTouchPoints();if(!t){this.lastMidpoint=null,this.lastDistance=null;return}this.lastMidpoint=this.getMidpoint(t[0],t[1]),this.lastDistance=this.getDistance(t[0],t[1])}getTwoTouchPoints(){if(this.pointers.size<2)return null;const t=this.pointers.values(),n=t.next().value,o=t.next().value;return!n||!o?null:[n,o]}getMidpoint(t,n){return{x:(t.x+n.x)*.5,y:(t.y+n.y)*.5}}getDistance(t,n){return Math.hypot(n.x-t.x,n.y-t.y)}getDragMode(t){return t.shiftKey||t.button===1?"pan":t.button===0?"orbit":null}}const Bs=`struct FrameUniforms {
  viewProj: mat4x4<f32>,
  cameraPos: vec3<f32>,
  devicePixelRatio: f32,
  cameraDir: vec3<f32>,
  _pad0: f32,
  viewport: vec4<f32>,
};

struct ObjectUniforms {
  model: mat4x4<f32>,
  color: vec4<f32>,
  material: vec4<f32>,
  pick: vec4<f32>,
};

@group(0) @binding(0)
var<uniform> frame: FrameUniforms;

@group(1) @binding(0)
var<uniform> object: ObjectUniforms;

struct VertexIn {
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
};

struct VertexOut {
  @builtin(position) position: vec4<f32>,
  @location(0) normal: vec3<f32>,
  @location(1) worldPos: vec3<f32>,
};

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  var out: VertexOut;
  let worldPos = object.model * vec4<f32>(input.position, 1.0);
  out.position = frame.viewProj * worldPos;
  out.normal = normalize((object.model * vec4<f32>(input.normal, 0.0)).xyz);
  out.worldPos = worldPos.xyz;
  return out;
}

// Fade to the average coverage when the pattern is sub-pixel to avoid moire.
fn resolvePattern(value: f32, duty: f32, fw: f32) -> f32 {
  let safeFw = max(fw, 1e-5);
  let fade = clamp(0.5 / safeFw, 0.0, 1.0);
  let clampedDuty = clamp(duty, 0.0, 1.0);
  return mix(clampedDuty, value, fade);
}

// Derivative-based antialiasing for periodic line patterns in screen space.
fn aaLine(u: f32, spacing: f32, thickness: f32) -> f32 {
  let safeSpacing = max(spacing, 1e-5);
  let coord = u / safeSpacing;
  let dist = abs(fract(coord) - 0.5);
  let fw = fwidth(coord);
  let width = clamp(thickness / safeSpacing, 0.0, 1.0);
  let halfWidth = 0.5 * width;
  let line = 1.0 - smoothstep(halfWidth - fw, halfWidth + fw, dist);
  return resolvePattern(line, width, fw);
}

// Antialiased on/off pulse along a period (used for dash segments).
fn aaPulse(u: f32, period: f32, length: f32) -> f32 {
  let safePeriod = max(period, 1e-5);
  let coord = u / safePeriod;
  let phase = fract(coord);
  let fw = fwidth(coord);
  let duty = clamp(length / safePeriod, 0.0, 1.0);
  let head = smoothstep(0.0, fw, phase);
  let tail = 1.0 - smoothstep(duty - fw, duty + fw, phase);
  let pulse = head * tail;
  return resolvePattern(pulse, duty, fw);
}

fn lineMask(
  screenPx: vec2<f32>,
  normal: vec2<f32>,
  spacing: f32,
  thickness: f32
) -> f32 {
  let u = dot(screenPx, normal);
  return aaLine(u, spacing, thickness);
}

fn dashMask(screenPx: vec2<f32>) -> f32 {
  let rowSpacing = 9.0;
  let dashLength = 12.5;
  let dashPeriod = 36.0;
  let thickness = 0.25;
  let rowIndex = floor(screenPx.y / rowSpacing);
  let phase = f32(i32(rowIndex) % 3) * (dashPeriod / 3.0);
  let row = aaLine(screenPx.y, rowSpacing, thickness);
  let dash = aaPulse(screenPx.x + phase, dashPeriod, dashLength);
  return row * dash;
}

fn dashedLineMask(
  screenPx: vec2<f32>,
  normal: vec2<f32>,
  spacing: f32,
  thickness: f32,
  dashLength: f32,
  dashPeriod: f32,
  phase: f32
) -> f32 {
  let line = lineMask(screenPx, normal, spacing, thickness);
  let tangent = vec2<f32>(-normal.y, normal.x);
  let v = dot(screenPx, tangent) + phase;
  let dash = aaPulse(v, dashPeriod, dashLength);
  return line * dash;
}

fn hatchPattern(
  worldPos: vec3<f32>,
  n: vec3<f32>,
  patternId: i32,
  surfaceScale: f32
) -> f32 {
  if (patternId == 0) {
    return 0.0;
  }

  var u = 0.0;
  var v = 0.0;
  let an = abs(n);
  if (an.y >= an.x && an.y >= an.z) {
    u = worldPos.x;
    v = worldPos.z;
  } else if (an.x >= an.z) {
    u = worldPos.z;
    v = worldPos.y;
  } else {
    u = worldPos.x;
    v = worldPos.y;
  }

  let surfacePx = vec2(u, v) * max(surfaceScale, 1e-4);
  let normalA = vec2<f32>(-0.70710678, 0.70710678);
  let normalB = vec2<f32>(0.70710678, 0.70710678);

  if (patternId == 1) {
    let a = lineMask(surfacePx, normalA, 12.0, 0.25);
    let b = lineMask(surfacePx, normalB, 12.0, 0.25);
    return max(a, b);
  } else if (patternId == 2) {
    return dashedLineMask(surfacePx, normalA, 9.0, 0.25, 8.0, 10.0, 0.0);
  } else if (patternId == 3) {
    return dashMask(surfacePx);
  }

  return 0.0;
}

fn gridMask(worldPos: vec3<f32>, spacing: f32) -> f32 {
  if (spacing <= 0.0) {
    return 0.0;
  }
  let s = max(1e-4, spacing);
  let thickness = 0.0075;
  let lineX = gridLineMask(worldPos.x, s, thickness);
  let lineZ = gridLineMask(worldPos.z, s, thickness);
  return max(lineX, lineZ);
}

fn gridLineMask(u: f32, spacing: f32, thickness: f32) -> f32 {
  let coord = u / spacing;
  let dist = abs(fract(coord) - 0.5);
  let fw = max(fwidth(coord), 1e-4);
  let halfWidth = 0.5 * (thickness / spacing);
  return 1.0 - smoothstep(halfWidth - fw, halfWidth + fw, dist);
}

@fragment
fn fsMain(input: VertexOut, @builtin(front_facing) isFront: bool) -> @location(0) vec4<f32> {
  let light = normalize(-frame.cameraDir);
  let n = normalize(input.normal);
  let shadeNormal = select(-n, n, isFront);
  var ndotl = 0.0;
  let fill = 0.4;
  let materialType = i32(round(object.material.y));
  let patternId = i32(round(object.material.x));
  let gridOnly = object.material.w;

  if (materialType == 4) {
    // Used for pickable-but-hidden surfaces (e.g. Sections Mesh mode).
    discard;
  }

  if (materialType == 1) {
    ndotl = abs(dot(n, light));
  } else {
    ndotl = max(dot(shadeNormal, light), 0.0);
  }

  let lightFactor = min(1.0, ndotl + fill);
  let base = object.color.rgb * lightFactor;

  if (materialType == 1) {
    let grid = gridMask(input.worldPos, object.material.z);
    let gridColor = vec3<f32>(0.55, 0.55, 0.55);
    if (gridOnly > 0.5) {
      if (grid <= 0.0) {
        discard;
      }
      let color = mix(base, gridColor, grid);
      return vec4<f32>(color, 1.0);
    }
    let color = mix(base, gridColor, grid);
    return vec4<f32>(color, object.color.a);
  }

  if (materialType == 3) {
    let viewDir = normalize(frame.cameraPos - input.worldPos);
    let fresnel = pow(1.0 - max(dot(shadeNormal, viewDir), 0.0), 3.0);
    let glassLight = mix(0.65, 1.0, ndotl);
    let glassBase = object.color.rgb * glassLight;
    let rim = mix(glassBase, vec3<f32>(1.0, 1.0, 1.0), 0.6);
    let keyLight = normalize(vec3<f32>(0.35, 0.85, 0.25));
    let halfVec = normalize(keyLight + viewDir);
    let spec = pow(max(dot(shadeNormal, halfVec), 0.0), 64.0);
    // Key lights are positioned from the default camera view to hit front/top faces on load.
    let keyLight1 = normalize(vec3<f32>(-0.805159, 0.326138, 0.495332));
    let keyLight2 = normalize(vec3<f32>(0.805159, 0.326138, -0.495332));
    let halfVec1 = normalize(keyLight1 + viewDir);
    let halfVec2 = normalize(keyLight2 + viewDir);
    let spec1 = pow(max(dot(shadeNormal, halfVec1), 0.0), 64.0);
    let spec2 = pow(max(dot(shadeNormal, halfVec2), 0.0), 64.0);
    let extraSpec = (spec1 + spec2) * 0.18;
    let color = mix(glassBase, rim, fresnel) + spec * 0.25 + extraSpec;
    let alpha = clamp(object.color.a * (0.7 + 0.7 * fresnel), 0.0, 1.0);
    if (patternId != 0) {
      // Preserve soil hatch even in glass mode (helps keep sections readable while transparent).
      let hatch = hatchPattern(input.worldPos, n, patternId, object.material.w);
      let ink = vec3<f32>(0.0, 0.0, 0.0);
      let hatched = mix(color, ink, clamp(hatch * 0.65, 0.0, 1.0));
      let hatchedAlpha = clamp(alpha + hatch * 0.15, 0.0, 1.0);
      return vec4<f32>(hatched, hatchedAlpha);
    }
    return vec4<f32>(color, alpha);
  }

  if (patternId == 0) {
    return vec4<f32>(base, object.color.a);
  }

  let hatch = hatchPattern(input.worldPos, n, patternId, object.material.w);

  let ink = vec3<f32>(0.0, 0.0, 0.0);
  let color = mix(base, ink, hatch);
  return vec4<f32>(color, object.color.a);
}
`,ks=`struct FrameUniforms {
  viewProj: mat4x4<f32>,
  cameraPos: vec3<f32>,
  devicePixelRatio: f32,
  cameraDir: vec3<f32>,
  _pad0: f32,
  viewport: vec4<f32>,
};

struct ObjectUniforms {
  model: mat4x4<f32>,
  color: vec4<f32>,
  material: vec4<f32>,
  pick: vec4<f32>,
};

@group(0) @binding(0)
var<uniform> frame: FrameUniforms;

@group(1) @binding(0)
var<uniform> object: ObjectUniforms;

struct VertexIn {
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
};

struct VertexOut {
  @builtin(position) position: vec4<f32>,
};

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  var out: VertexOut;
  let worldPos = object.model * vec4<f32>(input.position, 1.0);
  out.position = frame.viewProj * worldPos;
  return out;
}

fn encodeId(id: u32) -> vec4<f32> {
  let r = f32((id >> 0u) & 0xFFu) / 255.0;
  let g = f32((id >> 8u) & 0xFFu) / 255.0;
  let b = f32((id >> 16u) & 0xFFu) / 255.0;
  let a = f32((id >> 24u) & 0xFFu) / 255.0;
  return vec4<f32>(r, g, b, a);
}

@fragment
fn fsMain() -> @location(0) vec4<f32> {
  let id = u32(object.pick.x);
  return encodeId(id);
}
`,Ls=`struct FrameUniforms {
  viewProj: mat4x4<f32>,
  cameraPos: vec3<f32>,
  devicePixelRatio: f32,
  cameraDir: vec3<f32>,
  _pad0: f32,
  viewport: vec4<f32>,
};

struct ObjectUniforms {
  model: mat4x4<f32>,
  color: vec4<f32>,
  material: vec4<f32>,
  pick: vec4<f32>,
};

@group(0) @binding(0)
var<uniform> frame: FrameUniforms;

@group(1) @binding(0)
var<uniform> object: ObjectUniforms;

struct VertexIn {
  @location(0) start: vec3<f32>,
  @location(1) end: vec3<f32>,
  @location(2) side: f32,
  @location(3) along: f32,
};

struct VertexOut {
  @builtin(position) position: vec4<f32>,
};

fn ndcToScreen(ndc: vec2<f32>, viewport: vec2<f32>) -> vec2<f32> {
  let x = (ndc.x * 0.5 + 0.5) * viewport.x;
  let y = (1.0 - (ndc.y * 0.5 + 0.5)) * viewport.y;
  return vec2<f32>(x, y);
}

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  let startClip = frame.viewProj * vec4<f32>(input.start, 1.0);
  let endClip = frame.viewProj * vec4<f32>(input.end, 1.0);
  let startNdc = startClip.xy / startClip.w;
  let endNdc = endClip.xy / endClip.w;

  let viewport = frame.viewport.xy;
  let startScreen = ndcToScreen(startNdc, viewport);
  let endScreen = ndcToScreen(endNdc, viewport);
  var dirScreen = endScreen - startScreen;
  let len = length(dirScreen);
  if (len < 1e-4) {
    dirScreen = vec2<f32>(1.0, 0.0);
  } else {
    dirScreen = dirScreen / len;
  }
  let perp = vec2<f32>(-dirScreen.y, dirScreen.x);
  let halfWidth = 3.0;
  let offsetScreen = perp * (halfWidth * input.side);
  let offsetNdc = vec2<f32>(
    offsetScreen.x * frame.viewport.z * 2.0,
    -offsetScreen.y * frame.viewport.w * 2.0
  );

  let baseClip = mix(startClip, endClip, input.along);
  let baseNdc = baseClip.xy / baseClip.w;
  let finalNdc = baseNdc + offsetNdc;

  var out: VertexOut;
  out.position = vec4<f32>(finalNdc * baseClip.w, baseClip.z, baseClip.w);
  return out;
}

@fragment
fn fsMain() -> @location(0) vec4<f32> {
  return object.color;
}
`,Rs=`struct FrameUniforms {
  viewProj: mat4x4<f32>,
  cameraPos: vec3<f32>,
  devicePixelRatio: f32,
  cameraDir: vec3<f32>,
  _pad0: f32,
  viewport: vec4<f32>,
};

struct ObjectUniforms {
  model: mat4x4<f32>,
  color: vec4<f32>,
  material: vec4<f32>,
  pick: vec4<f32>,
};

@group(0) @binding(0)
var<uniform> frame: FrameUniforms;

@group(1) @binding(0)
var<uniform> object: ObjectUniforms;

struct VertexIn {
  @location(0) position: vec3<f32>,
};

struct VertexOut {
  @builtin(position) position: vec4<f32>,
};

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  var out: VertexOut;
  let worldPos = object.model * vec4<f32>(input.position, 1.0);
  out.position = frame.viewProj * worldPos;
  return out;
}

@fragment
fn fsMain() -> @location(0) vec4<f32> {
  return object.color;
}

`,_s=`struct FrameUniforms {
  viewProj: mat4x4<f32>,
  cameraPos: vec3<f32>,
  devicePixelRatio: f32,
  cameraDir: vec3<f32>,
  _pad0: f32,
  viewport: vec4<f32>,
};

struct ObjectUniforms {
  model: mat4x4<f32>,
  color: vec4<f32>,
  material: vec4<f32>,
  pick: vec4<f32>,
};

@group(0) @binding(0)
var<uniform> frame: FrameUniforms;

@group(1) @binding(0)
var<uniform> object: ObjectUniforms;

struct VertexIn {
  @location(0) aPos: vec3<f32>,
  @location(1) bPos: vec3<f32>,
  @location(2) n0: vec3<f32>,
  @location(3) n1: vec3<f32>,
  @location(4) side: f32,
  @location(5) along: f32,
};

struct VertexOut {
  @builtin(position) position: vec4<f32>,
  @location(0) @interpolate(flat) lineA: vec2<f32>,
  @location(1) @interpolate(flat) lineB: vec2<f32>,
  @location(2) @interpolate(flat) visibility: f32,
};

fn ndcToScreen(ndc: vec2<f32>) -> vec2<f32> {
  let uv = ndc * 0.5 + vec2<f32>(0.5, 0.5);
  return vec2<f32>(uv.x * frame.viewport.x, (1.0 - uv.y) * frame.viewport.y);
}

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  var out: VertexOut;

  let worldA = object.model * vec4<f32>(input.aPos, 1.0);
  let worldB = object.model * vec4<f32>(input.bPos, 1.0);
  let clipA = frame.viewProj * worldA;
  let clipB = frame.viewProj * worldB;

  let ndcA = clipA.xy / clipA.w;
  let ndcB = clipB.xy / clipB.w;
  let screenA = ndcToScreen(ndcA);
  let screenB = ndcToScreen(ndcB);
  out.lineA = screenA;
  out.lineB = screenB;

  let dir = screenB - screenA;
  let len = max(1e-4, length(dir));
  let tangent = dir / len;
  let normal = vec2<f32>(-tangent.y, tangent.x);

  let halfWidth = 1.0;
  let offsetPx = normal * (input.side * halfWidth);
  let offsetNdc = vec2<f32>(
    offsetPx.x * frame.viewport.z * 2.0,
    -offsetPx.y * frame.viewport.w * 2.0
  );

  let base = mix(clipA, clipB, input.along);
  let biasedZ = max(0.0, base.z);
  let shifted = vec4<f32>(
    base.xy + offsetNdc * base.w,
    biasedZ,
    base.w
  );
  out.position = shifted;

  out.visibility = 1.0;
  return out;
}

@fragment
fn fsMain(input: VertexOut) -> @location(0) vec4<f32> {
  if (input.visibility <= 0.0) {
    discard;
  }
  let a = input.lineA;
  let b = input.lineB;
  let ab = b - a;
  let len2 = max(1e-4, dot(ab, ab));

  let p = input.position.xy / frame.devicePixelRatio;
  let t = clamp(dot(p - a, ab) / len2, 0.0, 1.0);
  let proj = a + ab * t;
  let dist = length(p - proj);

  let halfWidth = 1.0;
  let aa = max(0.5, fwidth(dist));
  let mask = 1.0 - smoothstep(halfWidth - aa, halfWidth + aa, dist);
  return vec4<f32>(object.color.rgb, object.color.a * mask);
}
`,Us={r:21/255,g:21/255,b:21/255,a:1},Vo=3;class Ds{constructor(t,n,o,a,i){j(this,"pipeline");j(this,"terrainPipeline");j(this,"glassBackPipeline");j(this,"glassFrontPipeline");j(this,"curvePipeline");j(this,"wireframePipeline");j(this,"edgePipeline");j(this,"edgeOccludedPipeline");j(this,"pickPipeline");j(this,"frameBindGroupLayout");j(this,"objectBindGroupLayout");j(this,"pipelineLayout");j(this,"frameUniformBuffer");j(this,"frameUniformData");j(this,"frameBindGroup");j(this,"depthTexture",null);j(this,"depthView",null);j(this,"pickTexture",null);j(this,"pickView",null);j(this,"pickDepthTexture",null);j(this,"pickDepthView",null);j(this,"pickBuffer",null);j(this,"objects",[]);j(this,"size",{width:0,height:0,dpr:1});j(this,"cameraDir",Ye());j(this,"clearColor",{...Us});j(this,"overlayRenderer",null);this.canvas=t,this.device=n,this.context=o,this.format=a,this.gpuGuard=i,this.frameUniformData=new Float32Array(28),this.frameUniformBuffer=this.gpuCall("GPUDevice.createBuffer(frameUniformBuffer)",()=>this.device.createBuffer({size:this.frameUniformData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),this.frameBindGroupLayout=this.gpuCall("GPUDevice.createBindGroupLayout(frame)",()=>this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]})),this.objectBindGroupLayout=this.gpuCall("GPUDevice.createBindGroupLayout(object)",()=>this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]})),this.pipelineLayout=this.gpuCall("GPUDevice.createPipelineLayout",()=>this.device.createPipelineLayout({bindGroupLayouts:[this.frameBindGroupLayout,this.objectBindGroupLayout]})),this.pipeline=this.createPipeline("back"),this.terrainPipeline=this.createPipeline("none",!0),this.glassBackPipeline=this.createPipeline("front",!0,!1,"less-equal"),this.glassFrontPipeline=this.createPipeline("back",!0,!1,"less-equal"),this.curvePipeline=this.createCurvePipeline(),this.wireframePipeline=this.createWireframePipeline(),this.edgePipeline=this.createEdgeHighlightPipeline("always"),this.edgeOccludedPipeline=this.createEdgeHighlightPipeline("less-equal"),this.pickPipeline=this.createPickPipeline(),this.frameBindGroup=this.gpuCall("GPUDevice.createBindGroup(frame)",()=>this.device.createBindGroup({layout:this.frameBindGroupLayout,entries:[{binding:0,resource:{buffer:this.frameUniformBuffer}}]}))}gpuCall(t,n){return this.gpuGuard?this.gpuGuard.call(t,n):n()}gpuCallAsync(t,n){return this.gpuGuard?this.gpuGuard.callAsync(t,n):n()}setObjects(t){this.objects=t}setClearColor(t){this.clearColor={...t}}setOverlayRenderer(t){this.overlayRenderer=t}createRenderObject(t,n,o,a,i,c){const r=Uo(o),l=Uo(r),d=[...a],h=[...i],p=[...i],f=new Float32Array(28);f.set(r,0),f.set(a,16),f.set(h,20),f.set([0,0,0,0],24);const m=this.gpuCall("GPUDevice.createBuffer(objectUniform)",()=>this.device.createBuffer({size:f.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),y=this.gpuCall("GPUDevice.createBindGroup(object)",()=>this.device.createBindGroup({layout:this.objectBindGroupLayout,entries:[{binding:0,resource:{buffer:m}}]}));return this.gpuCall("GPUQueue.writeBuffer(objectUniform)",()=>this.device.queue.writeBuffer(m,0,f)),{id:t,mesh:n,modelMatrix:r,baseMatrix:l,color:a,baseColor:d,material:h,baseMaterial:p,objectType:c.objectType,layerIndex:c.layerIndex??0,visible:!0,soilId:c.soilId,sectionId:c.sectionId,profileId:c.profileId,pickId:0,edgeXray:!1,uniformBuffer:m,uniformData:f,bindGroup:y}}resize(){var r,l,d;const t=window.devicePixelRatio||1,n=Math.max(1,Math.floor(this.canvas.clientWidth*t)),o=Math.max(1,Math.floor(this.canvas.clientHeight*t));if(n===this.size.width&&o===this.size.height&&t===this.size.dpr)return;this.size={width:n,height:o,dpr:t},this.canvas.width=n,this.canvas.height=o,this.gpuCall("GPUCanvasContext.configure",()=>this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})),(r=this.depthTexture)==null||r.destroy();const a=this.gpuCall("GPUDevice.createTexture(depth)",()=>this.device.createTexture({size:{width:n,height:o},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}));this.depthTexture=a,this.depthView=this.gpuCall("GPUTexture.createView(depth)",()=>a.createView()),(l=this.pickTexture)==null||l.destroy();const i=this.gpuCall("GPUDevice.createTexture(pick)",()=>this.device.createTexture({size:{width:n,height:o},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}));this.pickTexture=i,this.pickView=this.gpuCall("GPUTexture.createView(pick)",()=>i.createView()),(d=this.pickDepthTexture)==null||d.destroy();const c=this.gpuCall("GPUDevice.createTexture(pickDepth)",()=>this.device.createTexture({size:{width:n,height:o},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}));this.pickDepthTexture=c,this.pickDepthView=this.gpuCall("GPUTexture.createView(pickDepth)",()=>c.createView()),this.pickBuffer||(this.pickBuffer=this.gpuCall("GPUDevice.createBuffer(pickReadback)",()=>this.device.createBuffer({size:256,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})))}getSize(){return this.size}render(t){this.objects.length!==0&&this.gpuCall("Renderer.render",()=>{this.resize();const n=t.getViewProjMatrix(),o=t.getPosition();Yn(this.cameraDir,t.target,o),at(this.cameraDir,this.cameraDir);const a=this.size.width/this.size.dpr,i=this.size.height/this.size.dpr;this.frameUniformData.set(n,0),this.frameUniformData.set([o[0],o[1],o[2],this.size.dpr],16),this.frameUniformData.set([this.cameraDir[0],this.cameraDir[1],this.cameraDir[2],0],20),this.frameUniformData.set([a,i,a>0?1/a:0,i>0?1/i:0],24),this.gpuCall("GPUQueue.writeBuffer(frameUniformBuffer)",()=>this.device.queue.writeBuffer(this.frameUniformBuffer,0,this.frameUniformData.buffer,this.frameUniformData.byteOffset,this.frameUniformData.byteLength));const c=t.mode==="perspective",r=c?i/(2*Math.tan(t.fov*.5)):i/(2*t.orthoScale),l=this.gpuCall("GPUCanvasContext.getCurrentTexture().createView",()=>this.context.getCurrentTexture().createView()),d=this.gpuCall("GPUDevice.createCommandEncoder",()=>this.device.createCommandEncoder()),h=this.gpuCall("GPUCommandEncoder.beginRenderPass",()=>d.beginRenderPass({colorAttachments:[{view:l,loadOp:"clear",storeOp:"store",clearValue:this.clearColor}],depthStencilAttachment:{view:this.depthView,depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}}));h.setBindGroup(0,this.frameBindGroup);let p=null;for(const f of this.objects){if(!f.visible)continue;const m=Math.round(f.material[1]);if((m===0||m===Vo)&&f.material[0]>0){const v=c?r/Math.max(t.distance,.01):r;f.material[3]=v}else m!==1&&(f.material[3]=1);if(f.uniformData.set(f.modelMatrix,0),f.uniformData.set(f.color,16),f.uniformData.set(f.material,20),f.uniformData.set([f.pickId??0,0,0,0],24),this.device.queue.writeBuffer(f.uniformBuffer,0,f.uniformData.buffer,f.uniformData.byteOffset,f.uniformData.byteLength),(f.objectType==="solid"||f.objectType==="section")&&Math.round(f.material[1])===Vo){p!==this.glassBackPipeline&&(h.setPipeline(this.glassBackPipeline),p=this.glassBackPipeline),h.setBindGroup(1,f.bindGroup),h.setVertexBuffer(0,f.mesh.vertexBuffer),h.draw(f.mesh.vertexCount,1,0,0),p!==this.glassFrontPipeline&&(h.setPipeline(this.glassFrontPipeline),p=this.glassFrontPipeline),h.setBindGroup(1,f.bindGroup),h.setVertexBuffer(0,f.mesh.vertexBuffer),h.draw(f.mesh.vertexCount,1,0,0);continue}const b=f.objectType==="curve"?this.curvePipeline:f.objectType==="solidWireframe"||f.objectType==="sectionWireframe"?this.wireframePipeline:f.objectType==="solidEdge"?f.edgeXray?this.edgePipeline:this.edgeOccludedPipeline:f.objectType==="terrain"||f.objectType==="solid"?this.terrainPipeline:this.pipeline;p!==b&&(h.setPipeline(b),p=b),h.setBindGroup(1,f.bindGroup),h.setVertexBuffer(0,f.mesh.vertexBuffer),h.draw(f.mesh.vertexCount,1,0,0)}if(h.end(),this.overlayRenderer){const f=this.gpuCall("GPUCommandEncoder.beginRenderPass(overlay)",()=>d.beginRenderPass({colorAttachments:[{view:l,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:this.depthView,depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}}));this.overlayRenderer(f,t),f.end()}this.gpuCall("GPUQueue.submit",()=>this.device.queue.submit([d.finish()]))})}async pick(t,n){return this.gpuCallAsync("Renderer.pick",async()=>{const o=this.pickTexture,a=this.pickView,i=this.pickDepthView,c=this.pickBuffer;if(!o||!a||!i||!c)return null;const r=Math.floor(t*this.size.dpr),l=Math.floor(n*this.size.dpr);if(r<0||l<0||r>=this.size.width||l>=this.size.height)return null;const d=this.gpuCall("GPUDevice.createCommandEncoder(pick)",()=>this.device.createCommandEncoder()),h=this.gpuCall("GPUCommandEncoder.beginRenderPass(pick)",()=>d.beginRenderPass({colorAttachments:[{view:a,loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:0}}],depthStencilAttachment:{view:i,depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}}));h.setPipeline(this.pickPipeline),h.setBindGroup(0,this.frameBindGroup);for(const m of this.objects)!m.visible||!m.pickId||(h.setBindGroup(1,m.bindGroup),h.setVertexBuffer(0,m.mesh.vertexBuffer),h.draw(m.mesh.vertexCount,1,0,0));h.end(),this.gpuCall("GPUCommandEncoder.copyTextureToBuffer(pick)",()=>d.copyTextureToBuffer({texture:o,origin:{x:r,y:l}},{buffer:c,bytesPerRow:256},{width:1,height:1,depthOrArrayLayers:1})),this.gpuCall("GPUQueue.submit(pick)",()=>this.device.queue.submit([d.finish()])),await this.gpuCallAsync("GPUBuffer.mapAsync(pickReadback)",()=>c.mapAsync(GPUMapMode.READ));const p=new Uint8Array(this.gpuCall("GPUBuffer.getMappedRange(pickReadback)",()=>c.getMappedRange())),f=p[0]|p[1]<<8|p[2]<<16|p[3]<<24;return this.gpuCall("GPUBuffer.unmap(pickReadback)",()=>c.unmap()),f===0?null:f})}createPipeline(t,n=!1,o=!0,a="less"){const i=[{format:this.format}];n&&(i[0].blend={color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}});const c=this.gpuCall("GPUDevice.createShaderModule(mesh)",()=>this.device.createShaderModule({code:Bs}));return this.gpuCall("GPUDevice.createRenderPipeline(mesh)",()=>this.device.createRenderPipeline({layout:this.pipelineLayout,vertex:{module:c,entryPoint:"vsMain",buffers:[{arrayStride:6*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*4,format:"float32x3"}]}]},fragment:{module:c,entryPoint:"fsMain",targets:i},primitive:{topology:"triangle-list",cullMode:t},depthStencil:{format:"depth24plus",depthWriteEnabled:o,depthCompare:a}}))}createCurvePipeline(){const t=this.gpuCall("GPUDevice.createShaderModule(curve)",()=>this.device.createShaderModule({code:Ls}));return this.gpuCall("GPUDevice.createRenderPipeline(curve)",()=>this.device.createRenderPipeline({layout:this.pipelineLayout,vertex:{module:t,entryPoint:"vsMain",buffers:[{arrayStride:32,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32"},{shaderLocation:3,offset:28,format:"float32"}]}]},fragment:{module:t,entryPoint:"fsMain",targets:[{format:this.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"less-equal",format:"depth24plus"}}))}createWireframePipeline(t="less-equal"){const n=this.gpuCall("GPUDevice.createShaderModule(wireframe)",()=>this.device.createShaderModule({code:Rs}));return this.gpuCall("GPUDevice.createRenderPipeline(wireframe)",()=>this.device.createRenderPipeline({layout:this.pipelineLayout,vertex:{module:n,entryPoint:"vsMain",buffers:[{arrayStride:6*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}]},fragment:{module:n,entryPoint:"fsMain",targets:[{format:this.format}]},primitive:{topology:"line-list",cullMode:"none"},depthStencil:{format:"depth24plus",depthWriteEnabled:!1,depthCompare:t}}))}createEdgeHighlightPipeline(t){const n=this.gpuCall("GPUDevice.createShaderModule(edgeHighlight)",()=>this.device.createShaderModule({code:_s}));return this.gpuCall("GPUDevice.createRenderPipeline(edgeHighlight)",()=>this.device.createRenderPipeline({layout:this.pipelineLayout,vertex:{module:n,entryPoint:"vsMain",buffers:[{arrayStride:14*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*4,format:"float32x3"},{shaderLocation:2,offset:6*4,format:"float32x3"},{shaderLocation:3,offset:9*4,format:"float32x3"},{shaderLocation:4,offset:12*4,format:"float32"},{shaderLocation:5,offset:13*4,format:"float32"}]}]},fragment:{module:n,entryPoint:"fsMain",targets:[{format:this.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{format:"depth24plus",depthWriteEnabled:!1,depthCompare:t}}))}createPickPipeline(){const t=this.gpuCall("GPUDevice.createShaderModule(pick)",()=>this.device.createShaderModule({code:ks}));return this.gpuCall("GPUDevice.createRenderPipeline(pick)",()=>this.device.createRenderPipeline({layout:this.pipelineLayout,vertex:{module:t,entryPoint:"vsMain",buffers:[{arrayStride:6*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*4,format:"float32x3"}]}]},fragment:{module:t,entryPoint:"fsMain",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}))}}async function Gs(e){const t=await fetch(e);if(!t.ok)throw new Error(`Failed to load scene: ${t.status}`);return await t.json()}function Vs(e){const t=new Float32Array([.5,-.5,-.5,1,0,0,.5,.5,-.5,1,0,0,.5,.5,.5,1,0,0,.5,-.5,-.5,1,0,0,.5,.5,.5,1,0,0,.5,-.5,.5,1,0,0,-.5,-.5,.5,-1,0,0,-.5,.5,.5,-1,0,0,-.5,.5,-.5,-1,0,0,-.5,-.5,.5,-1,0,0,-.5,.5,-.5,-1,0,0,-.5,-.5,-.5,-1,0,0,-.5,.5,-.5,0,1,0,-.5,.5,.5,0,1,0,.5,.5,.5,0,1,0,-.5,.5,-.5,0,1,0,.5,.5,.5,0,1,0,.5,.5,-.5,0,1,0,-.5,-.5,.5,0,-1,0,-.5,-.5,-.5,0,-1,0,.5,-.5,-.5,0,-1,0,-.5,-.5,.5,0,-1,0,.5,-.5,-.5,0,-1,0,.5,-.5,.5,0,-1,0,-.5,-.5,.5,0,0,1,.5,-.5,.5,0,0,1,.5,.5,.5,0,0,1,-.5,-.5,.5,0,0,1,.5,.5,.5,0,0,1,-.5,.5,.5,0,0,1,.5,-.5,-.5,0,0,-1,-.5,-.5,-.5,0,0,-1,-.5,.5,-.5,0,0,-1,.5,-.5,-.5,0,0,-1,-.5,.5,-.5,0,0,-1,.5,.5,-.5,0,0,-1]),n=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(n,0,t),{vertexBuffer:n,vertexCount:t.length/6}}const Os=1e-6;function Ys(e,t){if(t.length<2)return Oo(e);const n=[],o=(c,r,l,d)=>{n.push(c[0],c[1],c[2],r[0],r[1],r[2],l,d)};for(let c=0;c<t.length-1;c+=1){const r=t[c],l=t[c+1],d=l[0]-r[0],h=l[1]-r[1],p=l[2]-r[2];d*d+h*h+p*p<=Os||(o(r,l,-1,0),o(r,l,1,0),o(r,l,1,1),o(r,l,-1,0),o(r,l,1,1),o(r,l,-1,1))}const a=new Float32Array(n);if(a.length===0)return Oo(e);const i=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(i,0,a),{vertexBuffer:i,vertexCount:a.length/8}}function Oo(e){return{vertexBuffer:e.createBuffer({size:4,usage:GPUBufferUsage.VERTEX}),vertexCount:0}}function Yo(e,t,n,o,a=.02){const i=[],c=[],r=(d,h,p,f,m,y)=>{i.push(d,h,p,f,m,y)},l=(d,h,p)=>{c.push(d,h,p,0,0,0)};for(let d=0;d<t.length-1;d+=1){const[h,p]=t[d],[f,m]=t[d+1],y=f-h,b=m-p,v=Math.hypot(y,b);if(v<1e-4)continue;const g=b/v,A=-y/v,M=g*a,I=A*a,x=h+M,P=p+I,C=f+M,L=m+I,w=n,F=n,N=o,D=o;r(x,w,P,g,0,A),r(C,N,L,g,0,A),r(C,F,L,g,0,A),r(x,w,P,g,0,A),r(x,D,P,g,0,A),r(C,N,L,g,0,A),r(x,w,P,-g,0,-A),r(C,F,L,-g,0,-A),r(C,N,L,-g,0,-A),r(x,w,P,-g,0,-A),r(C,N,L,-g,0,-A),r(x,D,P,-g,0,-A),l(x,w,P),l(C,N,L),l(C,N,L),l(C,F,L),l(C,F,L),l(x,w,P),l(x,w,P),l(x,D,P),l(x,D,P),l(C,N,L),l(C,N,L),l(x,w,P)}return{solid:jo(e,new Float32Array(i)),wireframe:jo(e,new Float32Array(c))}}function jo(e,t,n=6){if(t.length===0)return js(e);const o=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(o,0,t),{vertexBuffer:o,vertexCount:t.length/n}}function js(e){return{vertexBuffer:e.createBuffer({size:4,usage:GPUBufferUsage.VERTEX}),vertexCount:0}}const Xs=1e-6;function Ws(e,t,n,o){const a=Math.floor(t.length/2),i=Math.floor(o.length/3);if(a<3||n.length!==a||i<1||o.length!==i*3)return Xo(e);const c=new Float32Array(a),r=new Float32Array(a),l=new Float32Array(a),d=g=>t[g*2],h=g=>t[g*2+1],p=g=>n[g];for(let g=0;g<o.length;g+=3){let A=o[g]|0,M=o[g+1]|0,I=o[g+2]|0;if(A<0||M<0||I<0||A>=a||M>=a||I>=a)continue;const x=d(A),P=h(A),C=d(M),L=h(M),w=d(I),F=h(I);if((C-x)*(F-P)-(L-P)*(w-x)<0){const ne=M;M=I,I=ne}const D=p(A),U=p(M),O=p(I),X=C-x,S=U-D,B=L-P,T=w-x,R=O-D,k=F-P,W=S*k-B*R,Y=B*T-X*k,Q=X*R-S*T;c[A]+=W,r[A]+=Y,l[A]+=Q,c[M]+=W,r[M]+=Y,l[M]+=Q,c[I]+=W,r[I]+=Y,l[I]+=Q}const f=new Float32Array(a*3);for(let g=0;g<a;g+=1){const A=c[g],M=r[g],I=l[g],x=Math.hypot(A,M,I);if(x<=Xs){f[g*3]=0,f[g*3+1]=1,f[g*3+2]=0;continue}f[g*3]=A/x,f[g*3+1]=M/x,f[g*3+2]=I/x}const m=[],y=g=>{m.push(d(g),p(g),h(g),f[g*3],f[g*3+1],f[g*3+2])};for(let g=0;g<o.length;g+=3){let A=o[g]|0,M=o[g+1]|0,I=o[g+2]|0;if(A<0||M<0||I<0||A>=a||M>=a||I>=a)continue;const x=d(A),P=h(A),C=d(M),L=h(M),w=d(I),F=h(I);if((C-x)*(F-P)-(L-P)*(w-x)<0){const D=M;M=I,I=D}y(A),y(M),y(I)}const b=new Float32Array(m);if(b.length===0)return Xo(e);const v=e.createBuffer({size:b.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(v,0,b),{vertexBuffer:v,vertexCount:b.length/6}}function Xo(e){return{vertexBuffer:e.createBuffer({size:4,usage:GPUBufferUsage.VERTEX}),vertexCount:0}}const qs=1e-6,It=6,$s=(e,t,n)=>Math.min(Math.max(e,t),n),Hs=(e,t,n)=>{const o=Math.hypot(e,t,n);return o<=qs?null:[e/o,t/o,n/o]},Sn=1e-5,Wo=(e,t,n)=>{const o=Math.round(e/Sn),a=Math.round(t/Sn),i=Math.round(n/Sn);return`${o},${a},${i}`};function Ks(e,t){if(e.length===0)return e;const n=new Map,o=[],a=(r,l,d,h,p,f)=>{o.push(r[0],r[1],r[2],l[0],l[1],l[2],d[0],d[1],d[2],h[0],h[1],h[2],p,f)},i=(r,l,d,h)=>{a(r,l,d,h,-1,0),a(r,l,d,h,1,0),a(r,l,d,h,1,1),a(r,l,d,h,-1,0),a(r,l,d,h,1,1),a(r,l,d,h,-1,1)},c=(r,l,d)=>{const h=Wo(r[0],r[1],r[2]),p=Wo(l[0],l[1],l[2]),f=h<p?`${h}|${p}`:`${p}|${h}`,m=n.get(f);if(!m){n.set(f,{a:r,b:l,normals:[d]});return}m.normals.push(d)};for(let r=0;r+It*3-1<e.length;r+=It*3){const l=e[r],d=e[r+1],h=e[r+2],p=e[r+It],f=e[r+It+1],m=e[r+It+2],y=e[r+It*2],b=e[r+It*2+1],v=e[r+It*2+2],g=p-l,A=f-d,M=m-h,I=y-l,x=b-d,P=v-h,C=A*P-M*x,L=M*I-g*P,w=g*x-A*I,F=Hs(C,L,w);if(!F)continue;const N=[l,d,h],D=[p,f,m],U=[y,b,v];c(N,D,F),c(D,U,F),c(U,N,F)}for(const r of n.values()){const l=r.normals;if(l.length===1){i(r.a,r.b,l[0],l[0]);continue}let d=1,h=null,p=null;for(let f=0;f<l.length;f+=1){const m=l[f];for(let y=f+1;y<l.length;y+=1){const b=l[y],v=$s(m[0]*b[0]+m[1]*b[1]+m[2]*b[2],-1,1);v<d&&(d=v,h=m,p=b)}}h&&p&&d<t&&i(r.a,r.b,h,p)}return o.length>0?new Float32Array(o):new Float32Array}const lt=1e-6,Qs=Math.cos(40*Math.PI/180);function Tn(e,t,n=6){if(t.length===0)return gi(e);const o=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(o,0,t),{vertexBuffer:o,vertexCount:t.length/n}}function Zs(e){if(e.length===0)return e;const t=new Float32Array(e.length*2);let n=0;for(let o=0;o+17<e.length;o+=18){const a=o,i=o+6,c=o+12;for(let r=0;r<6;r+=1)t[n++]=e[a+r];for(let r=0;r<6;r+=1)t[n++]=e[i+r];for(let r=0;r<6;r+=1)t[n++]=e[i+r];for(let r=0;r<6;r+=1)t[n++]=e[c+r];for(let r=0;r<6;r+=1)t[n++]=e[c+r];for(let r=0;r<6;r+=1)t[n++]=e[a+r]}return t}function Js(e,t){const n=Math.floor(t.length/3),o=new Int32Array(n*3);for(let a=0;a<n;a+=1){const i=a*3,c=t[i]|0;let r=t[i+1]|0,l=t[i+2]|0;const d=e[c*2],h=e[c*2+1],p=e[r*2],f=e[r*2+1],m=e[l*2],y=e[l*2+1];if((p-d)*(y-h)-(f-h)*(m-d)<0){const v=r;r=l,l=v}o[i]=c,o[i+1]=r,o[i+2]=l}return o}function qo(e,t,n,o){const a=Math.floor(e.length/2),i=new Float32Array(a*3);for(let c=0;c<n.length;c+=3){const r=n[c],l=n[c+1],d=n[c+2];if(r<0||l<0||d<0||r>=a||l>=a||d>=a)continue;const h=e[r*2],p=e[r*2+1],f=t[r],m=e[l*2],y=e[l*2+1],b=t[l],v=e[d*2],g=e[d*2+1],A=t[d],M=m-h,I=b-f,x=y-p,P=v-h,C=A-f,L=g-p;let w,F,N;o==="up"?(w=I*L-x*C,F=x*P-M*L,N=M*C-I*P):(w=C*x-L*I,F=L*M-P*x,N=P*I-C*M),i[r*3]+=w,i[r*3+1]+=F,i[r*3+2]+=N,i[l*3]+=w,i[l*3+1]+=F,i[l*3+2]+=N,i[d*3]+=w,i[d*3+1]+=F,i[d*3+2]+=N}for(let c=0;c<a;c+=1){const r=i[c*3],l=i[c*3+1],d=i[c*3+2],h=Math.hypot(r,l,d);if(h<=lt){i[c*3]=0,i[c*3+1]=o==="up"?1:-1,i[c*3+2]=0;continue}i[c*3]=r/h,i[c*3+1]=l/h,i[c*3+2]=d/h}return i}function er(e,t,n,o,a,i,c){const r=Math.floor(e.length/2),l=Math.floor(t.length/3);if(r<3||n.length!==r||o.length!==r||l<1||t.length!==l*3)return new Float32Array(0);const d=Js(e,t),h=a&&a.length===r*3?a:qo(e,n,d,"up"),p=i&&i.length===r*3?i:qo(e,o,d,"down"),f=[],m=(S,B)=>{f.push(S[0],S[1],S[2],B[0],B[1],B[2])},y=(S,B,T)=>{const R=S[0]+(B[0]-S[0])*T,k=S[1]+(B[1]-S[1])*T,W=S[2]+(B[2]-S[2])*T,Y=Math.hypot(R,k,W);return Y<=lt?[0,1,0]:[R/Y,k/Y,W/Y]},b=lt,v=S=>{const B=[];for(let T=0;T<S.length;T+=1){const R=S[T],k=S[(T+1)%S.length],W=R.thickness>b,Y=k.thickness>b;if(W&&Y){B.push(k);continue}if(W===Y)continue;const Q=k.thickness-R.thickness;if(Math.abs(Q)<=lt){Y&&B.push(k);continue}const ne=(b-R.thickness)/Q,z=R.x+(k.x-R.x)*ne,$=R.z+(k.z-R.z)*ne,J=R.yTop+(k.yTop-R.yTop)*ne,se=R.yBottom+(k.yBottom-R.yBottom)*ne,re=.5*(J+se);B.push({x:z,z:$,yTop:re,yBottom:re,thickness:0,nTop:y(R.nTop,k.nTop,ne),nBottom:y(R.nBottom,k.nBottom,ne)}),Y&&B.push(k)}return B},g=S=>{if(!(S.length<3)){for(let B=1;B+1<S.length;B+=1){const T=S[0],R=S[B],k=S[B+1];m([T.x,T.yTop,T.z],T.nTop),m([R.x,R.yTop,R.z],R.nTop),m([k.x,k.yTop,k.z],k.nTop)}for(let B=1;B+1<S.length;B+=1){const T=S[0],R=S[B],k=S[B+1];m([T.x,T.yBottom,T.z],T.nBottom),m([k.x,k.yBottom,k.z],k.nBottom),m([R.x,R.yBottom,R.z],R.nBottom)}}},A=(S,B,T)=>{S.thickness<=b&&B.thickness<=b&&T.thickness<=b||g(v([S,B,T]))},M=1e-5,I=new Int32Array(r),x=[],P=new Map;for(let S=0;S<r;S+=1){const B=e[S*2],T=e[S*2+1],R=Math.round(B/M),k=Math.round(T/M),W=`${R},${k}`;let Y=P.get(W);Y===void 0&&(Y=x.length,P.set(W,Y),x.push(S)),I[S]=Y}const C=c&&c.length>=3?c:t,L=new Map,w=(S,B)=>{const T=S<B?S:B,R=S<B?B:S;return BigInt(T)<<32n|BigInt(R)},F=(S,B,T)=>{const R=w(S,B),k=L.get(R);if(!k){L.set(R,{a:S,b:B,c:T,count:1});return}k.count+=1};for(let S=0;S+2<C.length;S+=3){const B=C[S]|0,T=C[S+1]|0,R=C[S+2]|0;if(B<0||T<0||R<0||B>=r||T>=r||R>=r)continue;const k=I[B],W=I[T],Y=I[R],Q=[],ne=(z,$,J)=>{if(z===$)return;const se=w(z,$);for(const re of Q)if(re===se)return;Q.push(se),F(z,$,J)};ne(k,W,Y),ne(W,Y,k),ne(Y,k,W)}for(let S=0;S<d.length;S+=3){const B=d[S],T=d[S+1],R=d[S+2];if(B<0||T<0||R<0||B>=r||T>=r||R>=r)continue;const k=e[B*2],W=e[B*2+1],Y=e[T*2],Q=e[T*2+1],ne=e[R*2],z=e[R*2+1],$={x:k,z:W,yTop:n[B],yBottom:o[B],thickness:n[B]-o[B],nTop:[h[B*3],h[B*3+1],h[B*3+2]],nBottom:[p[B*3],p[B*3+1],p[B*3+2]]},J={x:Y,z:Q,yTop:n[T],yBottom:o[T],thickness:n[T]-o[T],nTop:[h[T*3],h[T*3+1],h[T*3+2]],nBottom:[p[T*3],p[T*3+1],p[T*3+2]]},se={x:ne,z,yTop:n[R],yBottom:o[R],thickness:n[R]-o[R],nTop:[h[R*3],h[R*3+1],h[R*3+2]],nBottom:[p[R*3],p[R*3+1],p[R*3+2]]};A($,J,se)}const N=(S,B)=>{const T=S.thickness>b,R=B.thickness>b;if(T&&R)return[S,B];if(!T&&!R)return[];const k=B.thickness-S.thickness;if(Math.abs(k)<=lt)return T?[S]:[];const W=(b-S.thickness)/k,Y=S.x+(B.x-S.x)*W,Q=S.z+(B.z-S.z)*W,ne=S.yTop+(B.yTop-S.yTop)*W,z=S.yBottom+(B.yBottom-S.yBottom)*W,$={x:Y,z:Q,yTop:ne,yBottom:z,thickness:b};return T?[S,$]:[$,B]},D=(S,B,T)=>{const R=[S.x,S.yTop,S.z],k=[B.x,B.yTop,B.z],W=[S.x,S.yBottom,S.z],Y=[B.x,B.yBottom,B.z],Q=k[0]-R[0],ne=k[1]-R[1],z=k[2]-R[2],$=Y[0]-R[0],J=Y[1]-R[1],se=Y[2]-R[2],re=ne*se-z*J,le=z*$-Q*se,ae=Q*J-ne*$;if(re*T[0]+le*T[1]+ae*T[2]>=0){m(R,T),m(k,T),m(Y,T),m(R,T),m(Y,T),m(W,T);return}m(R,T),m(Y,T),m(k,T),m(R,T),m(W,T),m(Y,T)},U=.001,O=1e-4,X=(S,B)=>{for(let T=0;T<d.length;T+=3){const R=d[T],k=d[T+1],W=d[T+2];if(R<0||k<0||W<0||R>=r||k>=r||W>=r)continue;const Y=e[R*2],Q=e[R*2+1],ne=e[k*2],z=e[k*2+1],$=e[W*2],J=e[W*2+1],se=ne-Y,re=z-Q,le=$-Y,ae=J-Q,ce=S-Y,ue=B-Q,de=se*ae-re*le;if(Math.abs(de)<=lt)continue;const ee=(ce*ae-ue*le)/de,he=(se*ue-re*ce)/de,pe=1-ee-he;if(pe>=-lt&&ee>=-lt&&he>=-lt){const Se=n[R]*pe+n[k]*ee+n[W]*he,Ie=o[R]*pe+o[k]*ee+o[W]*he;return Se-Ie}}return null};for(const S of L.values()){if(S.count!==1)continue;const B=x[S.a],T=x[S.b],R=x[S.c];if(B===void 0||T===void 0||R===void 0)continue;const k=e[B*2],W=e[B*2+1],Y=e[T*2],Q=e[T*2+1],ne=.5*(k+Y),z=.5*(W+Q),$=Y-k;let se=Q-W,re=-$;const le=Math.hypot(se,re);if(le<=lt)continue;const ae=[se/le,0,re/le],ce=X(ne+ae[0]*U,z+ae[2]*U),ue=X(ne-ae[0]*U,z-ae[2]*U),de=ce!==null&&ce>O,ee=ue!==null&&ue>O;if(de&&ee)continue;const he=de?[-ae[0],0,-ae[2]]:ae,pe={x:k,z:W,yTop:n[B],yBottom:o[B],thickness:n[B]-o[B]},Se={x:Y,z:Q,yTop:n[T],yBottom:o[T],thickness:n[T]-o[T]},Ie=N(pe,Se);Ie.length===2&&D(Ie[0],Ie[1],he)}return new Float32Array(f)}function Gn(e,t,n,o,a,i,c,r){const l=Math.floor(t.length/2),d=Math.floor(n.length/3);if(l<3||d<1||t.length!==l*2||n.length!==d*3||o.length!==l||a.length!==l){const y=gi(e);return{solid:y,wireframe:y,edges:y}}const h=er(t,n,o,a,i,c,r),p=Tn(e,h),f=Tn(e,Zs(h)),m=Tn(e,Ks(h,Qs),14);return{solid:p,wireframe:f,edges:m}}function gi(e){return{vertexBuffer:e.createBuffer({size:4,usage:GPUBufferUsage.VERTEX}),vertexCount:0}}const dt=1e-6;function tr(e){const t=e.worldPath,n=t[0],o=t[t.length-1],a=o[0]-n[0],i=o[1]-n[1],c=Math.hypot(a,i),r=c>dt?a/c:1,l=c>dt?i/c:0,d=Number.isFinite(e.sScale)&&e.sScale>0?e.sScale:e.LWorld&&e.sMaxCad?e.LWorld/e.sMaxCad:1,h=-l,p=r,f=Math.hypot(h,p),m=f>dt?[h/f,0,p/f]:[0,0,1];return{origin:[n[0],n[1]],direction:[r,l],normal:m,sScale:d}}function xi(e,t){const n=e[0]*t.sScale,o=t.origin[0]+t.direction[0]*n,a=t.origin[1]+t.direction[1]*n;return[o,e[1],a]}function nr(e,t,n){const o=[],a=[],i=(d,h)=>{o.push(d[0],d[1],d[2],h[0],h[1],h[2])},c=d=>{a.push(d[0],d[1],d[2],0,0,0)},r=t.normal,l=[-r[0],-r[1],-r[2]];for(const d of n){const h=ir(d);if(h.length<3)continue;const p=rr(h);if(p.length===0)continue;const f=h.map(m=>xi(m,t));for(let m=0;m<p.length;m+=3){const y=p[m],b=p[m+1],v=p[m+2],g=f[y],A=f[b],M=f[v];i(g,r),i(A,r),i(M,r),i(g,l),i(M,l),i(A,l),c(g),c(A),c(A),c(M),c(M),c(g)}}return{solid:$o(e,new Float32Array(o)),wireframe:$o(e,new Float32Array(a))}}function $o(e,t,n=6){if(t.length===0)return or(e);const o=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(o,0,t),{vertexBuffer:o,vertexCount:t.length/n}}function or(e){return{vertexBuffer:e.createBuffer({size:4,usage:GPUBufferUsage.VERTEX}),vertexCount:0}}function ir(e){if(e.length<3)return[];const t=[];for(const i of e){const c=t[t.length-1];(!c||Math.hypot(i[0]-c[0],i[1]-c[1])>dt)&&t.push([i[0],i[1]])}if(t.length<3)return[];const n=t[0],o=t[t.length-1];if(Math.hypot(n[0]-o[0],n[1]-o[1])<=dt&&t.pop(),t.length<3)return[];const a=sr(t);return a.length<3?[]:(ar(a)<0&&a.reverse(),a)}function sr(e){const t=[],n=e.length;for(let o=0;o<n;o+=1){const a=e[(o-1+n)%n],i=e[o],c=e[(o+1)%n],r=Ot(a,i,c),l=i[0]-a[0],d=i[1]-a[1],h=c[0]-i[0],p=c[1]-i[1],f=l*h+d*p;Math.abs(r)<dt&&f>0||t.push(i)}return t}function rr(e){const t=[],n=e.length;if(n<3)return t;const o=Array.from({length:n},(c,r)=>r);let a=0;const i=n*n;for(;o.length>=3&&a<i;){a+=1;let c=!1;for(let r=0;r<o.length;r+=1){const l=o[(r-1+o.length)%o.length],d=o[r],h=o[(r+1)%o.length],p=e[l],f=e[d],m=e[h];if(!cr(p,f,m))continue;let y=!1;for(let b=0;b<o.length;b+=1){const v=o[b];if(!(v===l||v===d||v===h)&&lr(e[v],p,f,m)){y=!0;break}}if(!y){t.push(l,d,h),o.splice(r,1),c=!0;break}}if(!c){for(let r=1;r<o.length-1;r+=1)t.push(o[0],o[r],o[r+1]);break}}return t}function Ot(e,t,n){return(t[0]-e[0])*(n[1]-e[1])-(t[1]-e[1])*(n[0]-e[0])}function ar(e){let t=0;for(let n=0;n<e.length;n+=1){const o=e[n],a=e[(n+1)%e.length];t+=o[0]*a[1]-a[0]*o[1]}return t*.5}function cr(e,t,n){return Ot(e,t,n)>dt}function lr(e,t,n,o){const a=Ot(t,n,e),i=Ot(n,o,e),c=Ot(o,t,e);return a>=-dt&&i>=-dt&&c>=-dt}function dr(e){const t=new Float32Array([-.5,0,-.5,0,1,0,.5,0,.5,0,1,0,.5,0,-.5,0,1,0,-.5,0,-.5,0,1,0,-.5,0,.5,0,1,0,.5,0,.5,0,1,0]),n=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});return e.queue.writeBuffer(n,0,t),{vertexBuffer:n,vertexCount:t.length/6}}const En=[.7,.7,.7],hr=[.12,.5,.18],An=[.18,.9,.2],Nn={landfill:1,silt:2,clay:3},fr=.25,Cn=(e,t,n)=>{let o=n;return o<0?o+=1:o>1&&(o-=1),o<1/6?e+(t-e)*6*o:o<1/2?t:o<2/3?e+(t-e)*(2/3-o)*6:e},ur=(e,t)=>{const n=e[0],o=e[1],a=e[2],i=Math.max(n,o,a),c=Math.min(n,o,a);let r=0,l=0,d=(i+c)*.5;if(i!==c){const f=i-c;l=d>.5?f/(2-i-c):f/(i+c),i===n?r=(o-a)/f+(o<a?6:0):i===o?r=(a-n)/f+2:r=(n-o)/f+4,r/=6}if(d=Math.min(1,Math.max(0,d+t)),l===0)return[d,d,d];const h=d<.5?d*(1+l):d+l-d*l,p=2*d-h;return[Cn(p,h,r+1/3),Cn(p,h,r),Cn(p,h,r-1/3)]};function pr(e,t,n){var p;const o=new Map,a=[],i=Qe(),c=an(),r={min:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],max:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY]},l=new Map(n.soils.map(f=>[f.id,f])),d=n.objects.find(f=>f.type==="terrain")??null;let h=!1;if(n.solidsModel){const f=n.solidsModel,m=f.surfaces.terrain;if(m&&Array.isArray(m)){const y=f.mesh,b=Math.floor(y.verticesXZ.length/2);if(b>2&&m.length===b){const v=Ws(e,y.verticesXZ,m,y.triangles);if(v.vertexCount>0){const g=(d==null?void 0:d.color)??hr,M=[0,1,(d==null?void 0:d.gridScale)??1,0],I=t.createRenderObject((d==null?void 0:d.id)??"terrain",v,i,[g[0],g[1],g[2],1],M,{objectType:"terrain"});a.push(I),h=!0}}}}if((p=n.solidsModel)!=null&&p.sectionCurves)for(const f of n.solidsModel.sectionCurves){if(!f.points||f.points.length<2)continue;const m=Ys(e,f.points);if(m.vertexCount===0)continue;const y=[0,0,0,0],b=t.createRenderObject(`curve_${f.id}`,m,i,[An[0],An[1],An[2],1],y,{objectType:"curve"});a.push(b)}for(const f of n.objects){if(f.type!=="terrain"&&f.type!=="marker"||f.type==="terrain"&&h)continue;const m=mr(e,f,o),y=gr(f),b=f.soilId?l.get(f.soilId):void 0,v=f.color??(b==null?void 0:b.color)??En,g=f.type==="terrain"?1:f.type==="marker"?2:0,A=f.patternId??(b==null?void 0:b.patternId)??(f.soilId?Nn[f.soilId]:0)??0,M=g===0?A:0,I=f.gridScale??1,x=[M,g,I,0],P=t.createRenderObject(f.id,m,y,[v[0],v[1],v[2],1],x,{objectType:f.type,soilId:f.soilId});a.push(P),xr(r,f)}if(n.solidsModel){const f=n.solidsModel,{extent:m,surfaces:y,solids:b}=f,{verticesXZ:v,triangles:g}=f.mesh,A=Math.floor(v.length/2);let M=0;if(A>2)for(const P of b){const C=y[P.top],L=y[P.bottom];if(!C||!L||C.length!==A||L.length!==A){M+=1;continue}const{solid:w,wireframe:F,edges:N}=Gn(e,v,g,C,L);if(w.vertexCount===0){M+=1;continue}const D=l.get(P.soilId),U=(D==null?void 0:D.color)??En,X=[(D==null?void 0:D.patternId)??Nn[P.soilId]??0,0,0,0],S=t.createRenderObject(`solid_${P.id}`,w,i,[U[0],U[1],U[2],1],X,{objectType:"solid",soilId:P.soilId,layerIndex:M});if(a.push(S),F.vertexCount>0){const B=[0,2,0,0],T=t.createRenderObject(`solid_${P.id}_wireframe`,F,i,[U[0],U[1],U[2],1],B,{objectType:"solidWireframe",soilId:P.soilId,layerIndex:M});a.push(T)}if(N.vertexCount>0){const B=ur(U,fr),T=[0,2,0,0],R=t.createRenderObject(`solid_${P.id}_edge`,N,i,[B[0],B[1],B[2],1],T,{objectType:"solidEdge",soilId:P.soilId,layerIndex:M});a.push(R)}M+=1}const I=y.terrain,x=I&&Array.isArray(I)&&I.length>0?vr(I,m.yBase):m.yBase;r.min[0]=Math.min(r.min[0],m.xMin),r.max[0]=Math.max(r.max[0],m.xMax),r.min[2]=Math.min(r.min[2],m.zMin),r.max[2]=Math.max(r.max[2],m.zMax),r.min[1]=Math.min(r.min[1],m.yBase),r.max[1]=Math.max(r.max[1],x)}if(n.sections&&n.sections.length>0){const f=r.min[1],m=r.max[1];for(const y of n.sections)if(y.vector){const b=tr(y.vector);let v=!1;for(const[g,A]of Object.entries(y.vector.patches)){if(!A.rings||A.rings.length===0)continue;const M=nr(e,b,A.rings);if(M.solid.vertexCount===0)continue;const I=l.get(g),x=(I==null?void 0:I.color)??En,C=[(I==null?void 0:I.patternId)??Nn[g]??0,0,0,0],L=t.createRenderObject(`section_${y.id}_${g}`,M.solid,i,[x[0],x[1],x[2],1],C,{objectType:"section",sectionId:y.id,soilId:g});if(a.push(L),M.wireframe.vertexCount>0){const w=[0,2,0,0],F=t.createRenderObject(`section_${y.id}_${g}_wireframe`,M.wireframe,i,[x[0],x[1],x[2],1],w,{objectType:"sectionWireframe",sectionId:y.id,soilId:g});a.push(F)}v=!0}if(v)yr(r,b,y.vector);else{const g=Yo(e,y.path,f,m),A=[.788,.392,.788],M=[0,2,0,0],I=t.createRenderObject(`section_${y.id}`,g.solid,i,[A[0],A[1],A[2],1],M,{objectType:"section",sectionId:y.id});if(a.push(I),g.wireframe.vertexCount>0){const x=t.createRenderObject(`section_${y.id}_wireframe`,g.wireframe,i,[A[0],A[1],A[2],1],M,{objectType:"sectionWireframe",sectionId:y.id});a.push(x)}Ho(r,y,f,m)}}else{const b=Yo(e,y.path,f,m),v=[.788,.392,.788],g=[0,2,0,0],A=t.createRenderObject(`section_${y.id}`,b.solid,i,[v[0],v[1],v[2],1],g,{objectType:"section",sectionId:y.id});if(a.push(A),b.wireframe.vertexCount>0){const M=t.createRenderObject(`section_${y.id}_wireframe`,b.wireframe,i,[v[0],v[1],v[2],1],g,{objectType:"sectionWireframe",sectionId:y.id});a.push(M)}Ho(r,y,f,m)}}if(n.profiles&&n.profiles.length>0){const f=yi(e,o,"box"),m=.35,y=.08,b=[.43,.91,1];for(const v of n.profiles){const g=v.position.x,A=v.position.y,M=v.position.zGround,I=Math.max(v.depth,.01),x=Qe();Dn(x,c,Xe(g,M,A),Xe(m,m,m));const P=Qe();Dn(P,c,Xe(g,M-I*.5,A),Xe(y*2,I,y*2));const C=[0,2,0,0],L=t.createRenderObject(`profile_${v.id}_marker`,f,x,[b[0],b[1],b[2],1],C,{objectType:"profile",profileId:v.id}),w=t.createRenderObject(`profile_${v.id}_shaft`,f,P,[b[0],b[1],b[2],1],C,{objectType:"profile",profileId:v.id});a.push(L,w),br(r,v,m,y)}}return{objects:a,bounds:r,data:n}}function mr(e,t,n){const o=t.mesh.primitive;return yi(e,n,o)}function yi(e,t,n){const o=t.get(n);if(o)return o;let a;return n==="plane"?a=dr(e):a=Vs(e),t.set(n,a),a}function gr(e){const t=e.position??[0,0,0],n=e.rotation??[0,0,0],o=e.scale??[1,1,1],a=e.mesh.size??[1,1,1],i=[o[0]*a[0],o[1]*a[1],o[2]*a[2]],c=an();Ns(c,n[0],n[1],n[2]);const r=Qe();return Dn(r,c,Xe(t[0],t[1],t[2]),Xe(i[0],i[1],i[2])),r}function xr(e,t){const n=t.position??[0,0,0],o=t.mesh.size??[1,1,1],a=t.scale??[1,1,1],i=[o[0]*a[0]*.5,o[1]*a[1]*.5,o[2]*a[2]*.5],c=[n[0]-i[0],n[1]-i[1],n[2]-i[2]],r=[n[0]+i[0],n[1]+i[1],n[2]+i[2]];e.min[0]=Math.min(e.min[0],c[0]),e.min[1]=Math.min(e.min[1],c[1]),e.min[2]=Math.min(e.min[2],c[2]),e.max[0]=Math.max(e.max[0],r[0]),e.max[1]=Math.max(e.max[1],r[1]),e.max[2]=Math.max(e.max[2],r[2])}function Ho(e,t,n,o){for(const[a,i]of t.path)e.min[0]=Math.min(e.min[0],a),e.min[2]=Math.min(e.min[2],i),e.max[0]=Math.max(e.max[0],a),e.max[2]=Math.max(e.max[2],i);e.min[1]=Math.min(e.min[1],n),e.max[1]=Math.max(e.max[1],o)}function yr(e,t,n){for(const o of Object.values(n.patches))for(const a of o.rings)for(const i of a){const c=xi([i[0],i[1]],t);e.min[0]=Math.min(e.min[0],c[0]),e.min[1]=Math.min(e.min[1],c[1]),e.min[2]=Math.min(e.min[2],c[2]),e.max[0]=Math.max(e.max[0],c[0]),e.max[1]=Math.max(e.max[1],c[1]),e.max[2]=Math.max(e.max[2],c[2])}}function br(e,t,n,o){const a=t.position.x,i=t.position.y,c=t.position.zGround,r=Math.max(t.depth,.01),l=n*.5,h=Math.max(l,o);e.min[0]=Math.min(e.min[0],a-h),e.max[0]=Math.max(e.max[0],a+h),e.min[2]=Math.min(e.min[2],i-h),e.max[2]=Math.max(e.max[2],i+h),e.max[1]=Math.max(e.max[1],c+l),e.min[1]=Math.min(e.min[1],c-r)}function vr(e,t){let n=Number.NEGATIVE_INFINITY;for(const o of e)Number.isFinite(o)&&(n=Math.max(n,o));return Number.isFinite(n)?n:t}const We=1e-6,Vn=.001,Mr=Vn+1e-4,zn=.001;function bi(e,t,n){return Math.min(Math.max(e,t),n)}function Rt(e,t,n,o,a,i){return(n-e)*(i-t)-(o-t)*(a-e)}function Pr(e,t){const n=Math.floor(t.length/3),o=new Int32Array(n*3);for(let a=0;a<n;a+=1){const i=a*3,c=t[i]|0;let r=t[i+1]|0,l=t[i+2]|0;const d=e[c*2],h=e[c*2+1],p=e[r*2],f=e[r*2+1],m=e[l*2],y=e[l*2+1];if(Rt(d,h,p,f,m,y)<0){const v=r;r=l,l=v}o[i]=c,o[i+1]=r,o[i+2]=l}return o}function Ko(e,t,n,o){const a=Math.floor(e.length/2),i=new Float32Array(a*3);for(let c=0;c<n.length;c+=3){const r=n[c],l=n[c+1],d=n[c+2];if(r<0||l<0||d<0||r>=a||l>=a||d>=a)continue;const h=e[r*2],p=e[r*2+1],f=t[r],m=e[l*2],y=e[l*2+1],b=t[l],v=e[d*2],g=e[d*2+1],A=t[d],M=m-h,I=b-f,x=y-p,P=v-h,C=A-f,L=g-p;let w,F,N;o==="up"?(w=I*L-x*C,F=x*P-M*L,N=M*C-I*P):(w=C*x-L*I,F=L*M-P*x,N=P*I-C*M),i[r*3]+=w,i[r*3+1]+=F,i[r*3+2]+=N,i[l*3]+=w,i[l*3+1]+=F,i[l*3+2]+=N,i[d*3]+=w,i[d*3+1]+=F,i[d*3+2]+=N}for(let c=0;c<a;c+=1){const r=i[c*3],l=i[c*3+1],d=i[c*3+2],h=Math.hypot(r,l,d);if(h<=We){i[c*3]=0,i[c*3+1]=o==="up"?1:-1,i[c*3+2]=0;continue}i[c*3]=r/h,i[c*3+1]=l/h,i[c*3+2]=d/h}return i}const wr=e=>{const t=Math.hypot(e[0],e[1],e[2]);return t<=We?[0,1,0]:[e[0]/t,e[1]/t,e[2]/t]},Qo=(e,t,n)=>wr([e[0]+(t[0]-e[0])*n,e[1]+(t[1]-e[1])*n,e[2]+(t[2]-e[2])*n]);function Ir(e,t,n,o,a,i){const c=n.length;if(c===0)return{verticesXZ:[],triangles:[],top:[],bottom:[]};const r=new Int32Array(c),l=[],d=[],h=[],p=[],f=[],m=new Map,y=(x,P)=>a==="x"?Math.abs(x-i)<=Vn:Math.abs(P-i)<=Vn,b=(x,P)=>`${x},${P}`,v=x=>Math.floor(x/zn);for(let x=0;x<c;x+=1){const P=e[x*2],C=e[x*2+1];if(!y(P,C)){const D=h.length;l.push(P),d.push(C),h.push(n[x]),p.push(o[x]),f.push(1),r[x]=D;continue}const L=v(P),w=v(C);let F=-1;const N=zn*zn;for(let D=-1;D<=1&&F===-1;D+=1)for(let U=-1;U<=1&&F===-1;U+=1){const O=m.get(b(L+D,w+U));if(O)for(const X of O){const S=l[X]/f[X],B=d[X]/f[X];if((P-S)*(P-S)+(C-B)*(C-B)<=N){F=X;break}}}if(F===-1){F=h.length,l.push(P),d.push(C),h.push(n[x]),p.push(o[x]),f.push(1);const D=b(L,w),U=m.get(D);U?U.push(F):m.set(D,[F])}else l[F]+=P,d[F]+=C,h[F]+=n[x],p[F]+=o[x],f[F]+=1;r[x]=F}const g=new Array(l.length*2),A=new Array(h.length),M=new Array(p.length);for(let x=0;x<h.length;x+=1){const P=1/f[x];g[x*2]=l[x]*P,g[x*2+1]=d[x]*P,A[x]=h[x]*P,M[x]=p[x]*P}const I=[];for(let x=0;x+2<t.length;x+=3){const P=r[t[x]],C=r[t[x+1]],L=r[t[x+2]];if(P===C||C===L||L===P)continue;const w=g[P*2],F=g[P*2+1],N=g[C*2],D=g[C*2+1],U=g[L*2],O=g[L*2+1],X=Rt(w,F,N,D,U,O);Math.abs(X)<=We||I.push(P,C,L)}return{verticesXZ:g,triangles:I,top:A,bottom:M}}function cn(e,t,n,o,a,i,c){const r=Math.floor(e.length/2),l=Math.floor(t.length/3);if(r<3||l<1||e.length!==r*2||t.length!==l*3||n.length!==r||o.length!==r)return{verticesXZ:[],triangles:[],top:[],bottom:[]};const d=[],h=[],p=[],f=[],m=new Int32Array(r);m.fill(-1);const y=new Map,b=C=>Math.abs(C-i)<=Mr?i:C,v=C=>b(a==="x"?e[C*2]:e[C*2+1]),g=C=>{const L=v(C);return c==="max"?L<=i+We:L>=i-We},A=(C,L)=>{const w=C<L?C:L,F=C<L?L:C;return BigInt(w)<<32n|BigInt(F)},M=C=>{const L=m[C];if(L!==-1)return L;const w=h.length;m[C]=w;let F=e[C*2],N=e[C*2+1];return a==="x"?F=b(F):N=b(N),d.push(F,N),h.push(n[C]),p.push(o[C]),w},I=(C,L)=>{const w=v(C),F=v(L);if(Math.abs(w-i)<=We)return M(C);if(Math.abs(F-i)<=We)return M(L);const N=A(C,L),D=y.get(N);if(D!==void 0)return D;const U=e[C*2],O=e[C*2+1],X=e[L*2],S=e[L*2+1],B=n[C],T=o[C],R=n[L],k=o[L],W=F-w,Y=Math.abs(W)<=We?0:bi((i-w)/W,0,1);let Q=U+(X-U)*Y,ne=O+(S-O)*Y;a==="x"?Q=i:ne=i;const z=B+(R-B)*Y,$=T+(k-T)*Y,J=h.length;return y.set(N,J),d.push(Q,ne),h.push(z),p.push($),J},x=(C,L,w)=>{if(C===L||L===w||w===C)return;const F=d[C*2],N=d[C*2+1],D=d[L*2],U=d[L*2+1],O=d[w*2],X=d[w*2+1],S=Rt(F,N,D,U,O,X);Math.abs(S)<=We||f.push(C,L,w)},P=(C,L,w)=>{const F=[g(C),g(L),g(w)];if(!F[0]&&!F[1]&&!F[2])return;if(F[0]&&F[1]&&F[2]){x(M(C),M(L),M(w));return}const N=[],D=X=>{(N.length===0||N[N.length-1]!==X)&&N.push(X)},U=[C,L,w];for(let X=0;X<3;X+=1){const S=U[X],B=U[(X+1)%3],T=F[X],R=F[(X+1)%3];T&&R?D(M(B)):T&&!R?D(I(S,B)):!T&&R&&(D(I(S,B)),D(M(B)))}if(N.length>1&&N[0]===N[N.length-1]&&N.pop(),N.length<3)return;const O=N[0];for(let X=1;X+1<N.length;X+=1)x(O,N[X],N[X+1])};for(let C=0;C<l;C+=1){const L=C*3,w=t[L]|0,F=t[L+1]|0,N=t[L+2]|0;w<0||F<0||N<0||w>=r||F>=r||N>=r||P(w,F,N)}return Ir(d,f,h,p,a,i)}function Sr(e,t,n,o,a,i){const c=Math.floor(e.length/2),r=Math.floor(t.length/3);if(c<3||r<1||e.length!==c*2||t.length!==r*3||n.length!==c||o.length!==c)return{verticesXZ:[],triangles:[],top:[],bottom:[]};let l={verticesXZ:e,triangles:t,top:n,bottom:o};return a<Number.POSITIVE_INFINITY&&(l=cn(l.verticesXZ,l.triangles,l.top,l.bottom,"x",a,"max")),i<Number.POSITIVE_INFINITY&&(l=cn(l.verticesXZ,l.triangles,l.top,l.bottom,"z",i,"max")),l}function Tr(e,t,n,o,a,i=Number.NEGATIVE_INFINITY){const c=Math.floor(e.length/2),r=Math.floor(t.length/3);if(c<3||r<1||e.length!==c*2||t.length!==r*3||n.length!==c||o.length!==c)return{verticesXZ:[],triangles:[],top:[],bottom:[]};let l={verticesXZ:e,triangles:t,top:n,bottom:o};return a>Number.NEGATIVE_INFINITY&&(l=cn(l.verticesXZ,l.triangles,l.top,l.bottom,"x",a,"min")),i>Number.NEGATIVE_INFINITY&&(l=cn(l.verticesXZ,l.triangles,l.top,l.bottom,"z",i,"min")),l}function Er(e,t,n,o,a){const i=Math.floor(e.length/2),c=Math.floor(t.length/3);if(i<3||c<1||e.length!==i*2||t.length!==c*3||n.length!==i||o.length!==i)return{verticesXZ:[],triangles:[],boundaryTriangles:[],top:[],bottom:[],topNormals:[],bottomNormals:[]};const r=Pr(e,t),l=Ko(e,n,r,"up"),d=Ko(e,o,r,"down"),h=1e-5,p=1e-4,f=(w,F)=>{const N=Math.round(w.x/h),D=Math.round(w.z/h),U=Math.round(w.top/h),O=Math.round(w.bottom/h),X=Math.round(w.nTop[0]/p),S=Math.round(w.nTop[1]/p),B=Math.round(w.nTop[2]/p),T=Math.round(w.nBottom[0]/p),R=Math.round(w.nBottom[1]/p),k=Math.round(w.nBottom[2]/p);return`${N},${D},${U},${O},${X},${S},${B},${T},${R},${k}${F?"|cap":""}`},m=[],y=[],b=[],v=[],g=[],A=[],M=[],I=new Map,x=(w,F)=>{const N=f(w,F),D=I.get(N);if(D!==void 0)return D;const U=y.length;return I.set(N,U),m.push(w.x,w.z),y.push(w.top),b.push(w.bottom),v.push(w.nTop[0],w.nTop[1],w.nTop[2]),g.push(w.nBottom[0],w.nBottom[1],w.nBottom[2]),U},P=(w,F,N,D,U)=>{if(D){let T=Rt(w.x,w.z,F.x,F.z,N.x,N.z);if(T<0){const Q=F;F=N,N=Q,T=-T}const R=[0,-1,0];w={...w,nTop:R},F={...F,nTop:R},N={...N,nTop:R};const k=x(w,D),W=x(F,D),Y=x(N,D);if(M.push(k,W,Y),k===W||W===Y||Y===k||Math.abs(T)<=We)return;A.push(k,W,Y);return}let O=Rt(w.x,w.z,F.x,F.z,N.x,N.z);if(U!==0&&O*U<0){const T=F;F=N,N=T,O=-O}const X=x(w,D),S=x(F,D),B=x(N,D);M.push(X,S,B),!(X===S||S===B||B===X)&&(Math.abs(O)<=We||A.push(X,S,B))},C=w=>w.top>a?{...w,top:a}:w,L=(w,F)=>{const N=F.top-w.top;if(Math.abs(N)<=We)return{...w,top:a};const D=bi((a-w.top)/N,0,1);return{x:w.x+(F.x-w.x)*D,z:w.z+(F.z-w.z)*D,top:a,bottom:w.bottom+(F.bottom-w.bottom)*D,nTop:Qo(w.nTop,F.nTop,D),nBottom:Qo(w.nBottom,F.nBottom,D)}};for(let w=0;w<c;w+=1){const F=w*3,N=t[F]|0,D=t[F+1]|0,U=t[F+2]|0;if(N<0||D<0||U<0||N>=i||D>=i||U>=i)continue;const O={x:e[N*2],z:e[N*2+1],top:n[N],bottom:o[N],nTop:[l[N*3],l[N*3+1],l[N*3+2]],nBottom:[d[N*3],d[N*3+1],d[N*3+2]]},X={x:e[D*2],z:e[D*2+1],top:n[D],bottom:o[D],nTop:[l[D*3],l[D*3+1],l[D*3+2]],nBottom:[d[D*3],d[D*3+1],d[D*3+2]]},S={x:e[U*2],z:e[U*2+1],top:n[U],bottom:o[U],nTop:[l[U*3],l[U*3+1],l[U*3+2]],nBottom:[d[U*3],d[U*3+1],d[U*3+2]]},B=Rt(O.x,O.z,X.x,X.z,S.x,S.z),T=B===0?0:Math.sign(B),R=O.top>a+We,k=X.top>a+We,W=S.top>a+We,Y=(R?1:0)+(k?1:0)+(W?1:0);if(Y===0){P(O,X,S,!1,T);continue}if(Y===3){P(C(O),C(X),C(S),!0,T);continue}if(Y===1){let le=O,ae=X,ce=S;k?(le=X,ae=S,ce=O):W&&(le=S,ae=O,ce=X);const ue=L(le,ae),de=L(le,ce),ee=C(le);P(ae,ce,ue,!1,T),P(ce,de,ue,!1,T),P(ee,ue,de,!0,T);continue}let Q=O,ne=X,z=S;k?W||(Q=S,ne=O,z=X):(Q=X,ne=S,z=O);const $=L(ne,Q),J=L(z,Q),se=C(ne),re=C(z);P(Q,$,J,!1,T),P(se,re,J,!0,T),P(se,J,$,!0,T)}return{verticesXZ:m,triangles:A,boundaryTriangles:M,top:y,bottom:b,topNormals:v,bottomNormals:g}}const gt=e=>-e;function Ar(e){return e.map(t=>({...t,worldPath:t.worldPath.map(([n,o])=>[n,gt(o)])}))}function Nr(e){if(e.objects)for(const t of e.objects)t.position&&(t.position=[t.position[0],t.position[1],gt(t.position[2])]);if(e.sections&&(e.sections=e.sections.map(t=>({...t,path:t.path.map(([n,o])=>[n,gt(o)])}))),e.profiles)for(const t of e.profiles)t.position.y=gt(t.position.y)}function Cr(e){const t=e.extent.zMin,n=e.extent.zMax;if(e.extent.zMin=gt(n),e.extent.zMax=gt(t),e.sectionCurves)for(const i of e.sectionCurves)for(const c of i.points)c[2]=gt(c[2]);if(e.solidOutlines)for(const i of Object.values(e.solidOutlines.bySolid))for(const c of i)for(let r=2;r<c.length;r+=3)c[r]=gt(c[r]);const{verticesXZ:o,triangles:a}=e.mesh;for(let i=1;i<o.length;i+=2)o[i]=gt(o[i]);for(let i=0;i+2<a.length;i+=3){const c=a[i+1];a[i+1]=a[i+2],a[i+2]=c}}const zr=[{id:"s1",name:"Geological Section No. 1",sourceDxf:"sections/section_1.dxf",worldPath:[[.01,4.25],[19.99,2.13]],LWorld:20.09215767407771,sMaxCad:20.09,sScale:1.0001074004020762,zRef:5,zBase:-5.55,interfaces:{terrain:[[0,0],[.98,.47],[2.07,.99],[2.97,1.41],[4.32,2],[4.5,2.07],[5.74,2.55],[7.03,3],[8.1,3.26],[9.18,3.49],[10.32,3.73],[11.32,3.91],[12.18,4.06],[13.06,4.19],[13.55,4.25],[13.93,4.3],[15.06,4.44],[16.02,4.54],[18.34,4.79],[19.22,4.89],[20.09,5]],base:[[0,-5.55],[20.09,-5.55]],landfillBase:[[0,-1.19],[1.01,-.91],[2.01,-.54],[3.01,-.16],[4.02,.22],[5.04,.57],[6.07,.9],[7.1,1.2],[8.09,1.48],[9.12,1.78],[10.06,2.04],[11.06,2.26],[12.09,2.42],[13.13,2.53],[14.17,2.6],[15.22,2.67],[16.26,2.74],[17.54,2.83],[18.81,2.9],[20.09,2.95]],siltClay:[[0,-2.23],[1.01,-1.87],[2.01,-1.44],[3.05,-1.09],[5.18,-.49],[6.13,-.15],[7.03,.28],[8.04,.98],[9.03,1.72],[9.12,1.78]]},patches:{landfill:{rings:[[[1.01,-.91],[2.01,-.54],[3.01,-.16],[4.02,.22],[5.04,.57],[6.07,.9],[7.1,1.2],[8.09,1.48],[9.12,1.78],[10.06,2.04],[11.06,2.26],[12.09,2.42],[13.13,2.53],[14.17,2.6],[15.22,2.67],[16.26,2.74],[17.54,2.83],[18.81,2.9],[20.09,2.95],[20.09,5],[19.22,4.89],[18.34,4.79],[16.02,4.54],[15.06,4.44],[13.93,4.3],[13.55,4.25],[13.06,4.19],[12.18,4.06],[11.32,3.91],[10.32,3.73],[9.18,3.49],[8.1,3.26],[7.03,3],[5.74,2.55],[4.5,2.07],[4.32,2],[2.97,1.41],[2.07,.99],[.98,.47],[0,0],[0,-1.19]]]},clay:{rings:[[[20.09,-5.55],[20.09,2.95],[18.81,2.9],[17.54,2.83],[16.26,2.74],[15.22,2.67],[14.17,2.6],[13.13,2.53],[12.09,2.42],[11.06,2.26],[10.06,2.04],[9.12,1.78],[9.03,1.72],[8.04,.98],[7.03,.28],[6.13,-.15],[5.18,-.49],[3.05,-1.09],[2.01,-1.44],[1.01,-1.87],[0,-2.23],[0,-5.55]]]},silt:{rings:[[[1.01,-1.87],[2.01,-1.44],[3.05,-1.09],[5.18,-.49],[6.13,-.15],[7.03,.28],[8.04,.98],[9.03,1.72],[9.12,1.78],[8.09,1.48],[7.1,1.2],[6.07,.9],[5.04,.57],[4.02,.22],[3.01,-.16],[2.01,-.54],[1.01,-.91],[0,-1.19],[0,-2.23]]]}}},{id:"s2",name:"Section 2",sourceDxf:"sections/section_2.dxf",worldPath:[[2.11,9.68],[1.91,.43]],LWorld:9.25216190952147,sMaxCad:9.25,sScale:1.0002337199482672,zRef:.97,zBase:-5.55,interfaces:{terrain:[[0,.97],[.59,.95],[1.27,.94],[1.5,.94],[2.41,.94],[2.64,.94],[3.3,.95],[4.56,.95],[5.59,.95],[6.63,.94],[7.65,.92],[8.64,.9],[9.25,.88]],base:[[0,-5.55],[9.25,-5.55]],landfillBase:[[0,-.3],[.03,-.25],[.12,-.29],[.17,-.32],[1.26,-.36],[1.65,-.37],[2.35,-.4],[2.76,-.43],[3.45,-.46],[4.04,-.47],[4.55,-.52],[5.59,-.55],[5.68,-.54],[6.56,-.54],[7.68,-.55],[8.06,-.56],[8.68,-.58],[9.25,-.61]],siltClay:[[0,-1.7],[.03,-1.64],[.12,-1.68],[.17,-1.7],[.33,-1.7],[1.26,-1.67],[1.65,-1.64],[2.36,-1.6],[2.76,-1.59],[3.45,-1.55],[4.03,-1.5],[4.55,-1.5],[5.59,-1.45],[5.64,-1.45],[5.68,-1.45],[5.71,-1.45],[6.41,-1.47],[6.81,-1.49],[7.17,-1.52],[7.77,-1.56],[9.25,-1.67]]},patches:{landfill:{rings:[[[.03,-.25],[.12,-.29],[.17,-.32],[1.26,-.36],[1.65,-.37],[2.35,-.4],[2.76,-.43],[3.45,-.46],[4.04,-.47],[4.55,-.52],[5.59,-.55],[5.68,-.54],[6.56,-.54],[7.68,-.55],[8.06,-.56],[8.68,-.58],[9.25,-.61],[9.25,.88],[8.64,.9],[7.65,.92],[6.63,.94],[5.59,.95],[4.56,.95],[3.3,.95],[2.64,.94],[2.41,.94],[1.5,.94],[1.27,.94],[.59,.95],[0,.97],[0,-.3]]]},clay:{rings:[[[9.25,-5.55],[9.25,-1.67],[7.77,-1.56],[7.17,-1.52],[6.81,-1.49],[6.41,-1.47],[5.71,-1.45],[5.68,-1.45],[5.64,-1.45],[5.59,-1.45],[4.55,-1.5],[4.03,-1.5],[3.45,-1.55],[2.76,-1.59],[2.36,-1.6],[1.65,-1.64],[1.26,-1.67],[.33,-1.7],[.17,-1.7],[.12,-1.68],[.03,-1.64],[0,-1.7],[0,-5.55]]]},silt:{rings:[[[.03,-1.64],[.12,-1.68],[.17,-1.7],[.33,-1.7],[1.26,-1.67],[1.65,-1.64],[2.36,-1.6],[2.76,-1.59],[3.45,-1.55],[4.03,-1.5],[4.55,-1.5],[5.59,-1.45],[5.64,-1.45],[5.68,-1.45],[5.71,-1.45],[6.41,-1.47],[6.81,-1.49],[7.17,-1.52],[7.77,-1.56],[9.25,-1.67],[9.25,-.61],[8.68,-.58],[8.06,-.56],[7.68,-.55],[6.56,-.54],[5.68,-.54],[5.59,-.55],[4.55,-.52],[4.04,-.47],[3.45,-.46],[2.76,-.43],[2.35,-.4],[1.65,-.37],[1.26,-.36],[.17,-.32],[.12,-.29],[.03,-.25],[0,-.3],[0,-1.7]]]}}},{id:"s3",name:"Section 3",sourceDxf:"sections/section_3.dxf",worldPath:[[15.29,.45],[15.63,9.53]],LWorld:9.086363408977213,sMaxCad:9.09,sScale:.9995999349809915,zRef:4.48,zBase:-5.55,interfaces:{terrain:[[0,4.43],[.69,4.45],[1.83,4.48],[2.64,4.48],[2.95,4.48],[3.82,4.48],[4.98,4.47],[6.25,4.44],[6.46,4.43],[7.32,4.42],[7.96,4.42],[8.44,4.42],[9.09,4.44]],base:[[0,-5.55],[9.09,-5.55]],landfillClay:[[0,2.58],[.39,2.6],[1.86,2.65],[2.17,2.68],[3.71,2.75],[3.78,2.75],[4.96,2.76],[6.13,2.73],[7.3,2.58],[7.63,2.54],[8.38,2.43],[8.58,2.4],[9.09,2.31]]},patches:{landfill:{rings:[[[.39,2.6],[1.86,2.65],[2.17,2.68],[3.71,2.75],[3.78,2.75],[4.96,2.76],[6.13,2.73],[7.3,2.58],[7.63,2.54],[8.38,2.43],[8.58,2.4],[9.09,2.31],[9.09,4.44],[8.44,4.42],[7.96,4.42],[7.32,4.42],[6.46,4.43],[6.25,4.44],[4.98,4.47],[3.82,4.48],[2.95,4.48],[2.64,4.48],[1.83,4.48],[.69,4.45],[0,4.43],[0,2.58]]]},clay:{rings:[[[9.09,-5.55],[9.09,2.31],[8.58,2.4],[8.38,2.43],[7.63,2.54],[7.3,2.58],[6.13,2.73],[4.96,2.76],[3.78,2.75],[3.71,2.75],[2.17,2.68],[1.86,2.65],[.39,2.6],[0,2.58],[0,-5.55]]]}}},{id:"s4",name:"Section 4",sourceDxf:"sections/section_4.dxf",worldPath:[[.2,9.81],[19.72,9.72]],LWorld:19.52020747840555,sMaxCad:19.52,sScale:1.0000106290166777,zRef:4.96,zBase:-5.55,interfaces:{terrain:[[0,.09],[.72,.41],[.94,.51],[1.95,.99],[2.72,1.35],[3.72,1.82],[3.97,1.93],[4.73,2.26],[4.98,2.36],[5.76,2.66],[6.54,2.91],[6.8,3],[7.64,3.22],[7.87,3.28],[8.71,3.47],[8.94,3.52],[9.79,3.68],[10.03,3.73],[10.88,3.87],[11.13,3.9],[11.98,4.03],[12.23,4.06],[13.34,4.2],[14.46,4.33],[15.3,4.43],[15.57,4.46],[16.41,4.56],[16.69,4.59],[17.52,4.69],[17.71,4.71],[18.16,4.77],[18.8,4.86],[19.52,4.96]],base:[[0,-5.55],[19.52,-5.55]],landfillBase:[[0,-1.27],[.83,-.86],[.9,-.81],[1.45,-.6],[1.93,-.49],[2.4,-.37],[3.09,-.22],[3.55,-.03],[4.05,.08],[4.71,.19],[4.9,.23],[5.12,.24],[5.78,.2],[6.8,.25],[6.93,.28],[7.76,.44],[8.03,.49],[9.12,.73],[9.94,.92],[10.21,.99],[10.39,1.03],[11.03,1.19],[11.3,1.26],[12.11,1.47],[12.39,1.54],[13.2,1.74],[13.49,1.81],[14.28,2.01],[14.58,2.07],[15.37,2.26],[15.67,2.32],[16.46,2.49],[16.67,2.52],[17.51,2.68],[17.69,2.7],[18.13,2.76],[18.78,2.86],[19.44,2.93],[19.52,2.94]],siltClay:[[0,-2.65],[.82,-2.24],[.88,-2.2],[1.45,-2],[1.94,-1.92],[2.42,-1.83],[3.12,-1.72],[3.58,-1.54],[4.1,-1.44],[4.74,-1.37],[5.02,-1.3],[5.45,-1.28],[5.82,-1.31],[5.87,-1.3],[6.72,-1.17],[6.79,-1.15],[6.86,-1.11],[7.62,-.75],[7.85,-.62],[8.58,-.21],[8.81,-.06],[9.51,.4],[9.74,.56],[10.39,1.03]]},patches:{landfill:{rings:[[[.83,-.86],[.9,-.81],[1.45,-.6],[1.93,-.49],[2.4,-.37],[3.09,-.22],[3.55,-.03],[4.05,.08],[4.71,.19],[4.9,.23],[5.12,.24],[5.78,.2],[6.8,.25],[6.93,.28],[7.76,.44],[8.03,.49],[9.12,.73],[9.94,.92],[10.21,.99],[10.39,1.03],[11.03,1.19],[11.3,1.26],[12.11,1.47],[12.39,1.54],[13.2,1.74],[13.49,1.81],[14.28,2.01],[14.58,2.07],[15.37,2.26],[15.67,2.32],[16.46,2.49],[16.67,2.52],[17.51,2.68],[17.69,2.7],[18.13,2.76],[18.78,2.86],[19.44,2.93],[19.52,2.94],[19.52,4.96],[18.8,4.86],[18.16,4.77],[17.71,4.71],[17.52,4.69],[16.69,4.59],[16.41,4.56],[15.57,4.46],[15.3,4.43],[14.46,4.33],[13.34,4.2],[12.23,4.06],[11.98,4.03],[11.13,3.9],[10.88,3.87],[10.03,3.73],[9.79,3.68],[8.94,3.52],[8.71,3.47],[7.87,3.28],[7.64,3.22],[6.8,3],[6.54,2.91],[5.76,2.66],[4.98,2.36],[4.73,2.26],[3.97,1.93],[3.72,1.82],[2.72,1.35],[1.95,.99],[.94,.51],[.72,.41],[0,.09],[0,-1.27]]]},clay:{rings:[[[19.52,-5.55],[19.52,2.94],[19.44,2.93],[18.78,2.86],[18.13,2.76],[17.69,2.7],[17.51,2.68],[16.67,2.52],[16.46,2.49],[15.67,2.32],[15.37,2.26],[14.58,2.07],[14.28,2.01],[13.49,1.81],[13.2,1.74],[12.39,1.54],[12.11,1.47],[11.3,1.26],[11.03,1.19],[10.39,1.03],[9.74,.56],[9.51,.4],[8.81,-.06],[8.58,-.21],[7.85,-.62],[7.62,-.75],[6.86,-1.11],[6.79,-1.15],[6.72,-1.17],[5.87,-1.3],[5.82,-1.31],[5.45,-1.28],[5.02,-1.3],[4.74,-1.37],[4.1,-1.44],[3.58,-1.54],[3.12,-1.72],[2.42,-1.83],[1.94,-1.92],[1.45,-2],[.88,-2.2],[.82,-2.24],[0,-2.65],[0,-5.55]]]},silt:{rings:[[[.82,-2.24],[.88,-2.2],[1.45,-2],[1.94,-1.92],[2.42,-1.83],[3.12,-1.72],[3.58,-1.54],[4.1,-1.44],[4.74,-1.37],[5.02,-1.3],[5.45,-1.28],[5.82,-1.31],[5.87,-1.3],[6.72,-1.17],[6.79,-1.15],[6.86,-1.11],[7.62,-.75],[7.85,-.62],[8.58,-.21],[8.81,-.06],[9.51,.4],[9.74,.56],[10.39,1.03],[10.21,.99],[9.94,.92],[9.12,.73],[8.03,.49],[7.76,.44],[6.93,.28],[6.8,.25],[5.78,.2],[5.12,.24],[4.9,.23],[4.71,.19],[4.05,.08],[3.55,-.03],[3.09,-.22],[2.4,-.37],[1.93,-.49],[1.45,-.6],[.9,-.81],[.83,-.86],[0,-1.27],[0,-2.65]]]}}}],Fr={sections:zr},ln=1e-6,Zo=new WeakMap;function Br(e,t,n){const o=e.path;if(o.length<2)return null;const[a,i]=o[0],[c,r]=o[o.length-1],l=c-a,d=r-i,h=Math.hypot(l,d);if(!Number.isFinite(h)||h<=ln)return null;const p=l/h,f=d/h,m=t.surfaces,y=Lr(t),b=y.avgEdgeLength,v=Math.max(.01,b),g=Math.max(2,Math.floor(h/v)+1),A=new Map,M=(U,O,X)=>{const S=A.get(U)??m[U];return S?(A.set(U,S),_r(y,S,O,X)):0},I=[],x=[],P=Object.create(null),C=new Set;for(const U of t.solids)C.add(U.top),C.add(U.bottom);const L=Array.from(C);for(const U of L)P[U]=[];for(let U=0;U<g;U+=1){const O=U/(g-1)*h,X=a+p*O,S=i+f*O;I.push(O);const B=M("terrain",X,S);x.push(B);for(const T of L)P[T].push(M(T,X,S))}const w=Math.max(...x),F=[];let N=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY;for(const U of t.solids){const O=P[U.top],X=P[U.bottom];if(!O||!X)continue;let S=0;for(let T=0;T<O.length;T+=1)S=Math.max(S,O[T]-X[T]);if(S<=ln)continue;const B=[];for(let T=0;T<g;T+=1){const R=w-O[T];N=Math.min(N,R),D=Math.max(D,R),B.push({s:I[T],d:R})}for(let T=g-1;T>=0;T-=1){const R=w-X[T];N=Math.min(N,R),D=Math.max(D,R),B.push({s:I[T],d:R})}F.push({soilId:U.soilId,rings:[B]})}return!Number.isFinite(N)||F.length===0?null:{minS:0,maxS:h,minD:N,maxD:D,zRef:w,patches:F}}function kr(e,t){const n=Math.floor(e.length/2),o=Math.floor(t.length/3);if(n<3||o<1)return .25;const a=Math.min(o,200),i=Math.max(1,Math.floor(o/a));let c=0,r=0;for(let d=0;d<o;d+=i){const h=d*3,p=t[h]|0,f=t[h+1]|0,m=t[h+2]|0;p<0||f<0||m<0||p>=n||f>=n||m>=n||(c+=Fn(e,p,f),c+=Fn(e,f,m),c+=Fn(e,m,p),r+=3)}const l=r>0?c/r:.25;return Number.isFinite(l)&&l>0?l:.25}function Fn(e,t,n){const o=e[t*2],a=e[t*2+1],i=e[n*2],c=e[n*2+1];return Math.hypot(i-o,c-a)}function Jo(e,t,n){return Math.max(t,Math.min(n,e))}function dn(e,t,n){return Math.max(t,Math.min(n,e))}function Lr(e){const t=Zo.get(e);if(t)return t;const n=Rr(e);return Zo.set(e,n),n}function Rr(e){const{extent:t,mesh:n}=e,{verticesXZ:o,triangles:a}=n,i=Math.floor(o.length/2),c=Math.floor(a.length/3);if(i<3||c<1||o.length!==i*2||a.length!==c*3){const k=new Int32Array(2);return{xMin:t.xMin,xMax:t.xMax,zMin:t.zMin,zMax:t.zMax,cellSize:Math.max(.01,t.xMax-t.xMin,t.zMax-t.zMin),nx:1,nz:1,offsets:k,indices:new Int32Array(0),ia:new Int32Array(0),ib:new Int32Array(0),ic:new Int32Array(0),ax:new Float32Array(0),az:new Float32Array(0),v0x:new Float32Array(0),v0z:new Float32Array(0),v1x:new Float32Array(0),v1z:new Float32Array(0),invDenom:new Float32Array(0),avgEdgeLength:.25}}const r=t.xMin,l=t.xMax,d=t.zMin,h=t.zMax,p=Math.max(ln,l-r),f=Math.max(ln,h-d),m=kr(o,a),y=Math.max(p,f)/128,b=Math.max(.05,y,m),v=Math.max(1,Math.ceil(p/b)),g=Math.max(1,Math.ceil(f/b)),A=v*g,M=new Int32Array(c),I=new Int32Array(c),x=new Int32Array(c),P=new Float32Array(c),C=new Float32Array(c),L=new Float32Array(c),w=new Float32Array(c),F=new Float32Array(c),N=new Float32Array(c),D=new Float32Array(c),U=new Int32Array(A),O=k=>dn(Math.floor((k-r)/b),0,v-1),X=k=>dn(Math.floor((k-d)/b),0,g-1);for(let k=0;k<c;k+=1){const W=k*3,Y=a[W]|0,Q=a[W+1]|0,ne=a[W+2]|0;if(Y<0||Q<0||ne<0||Y>=i||Q>=i||ne>=i){M[k]=-1,I[k]=-1,x[k]=-1,D[k]=0;continue}M[k]=Y,I[k]=Q,x[k]=ne;const z=o[Y*2],$=o[Y*2+1],J=o[Q*2],se=o[Q*2+1],re=o[ne*2],le=o[ne*2+1];P[k]=z,C[k]=$;const ae=J-z,ce=se-$,ue=re-z,de=le-$;L[k]=ae,w[k]=ce,F[k]=ue,N[k]=de;const ee=ae*de-ce*ue;D[k]=Math.abs(ee)<=1e-12?0:1/ee;const he=Math.min(z,J,re),pe=Math.max(z,J,re),Se=Math.min($,se,le),Ie=Math.max($,se,le),Be=O(he),De=O(pe),Ge=X(Se),_e=X(Ie);for(let H=Ge;H<=_e;H+=1){const je=H*v;for(let Ce=Be;Ce<=De;Ce+=1)U[je+Ce]+=1}}const S=new Int32Array(A+1);for(let k=0;k<A;k+=1)S[k+1]=S[k]+U[k];const B=S[A],T=new Int32Array(B),R=new Int32Array(S);for(let k=0;k<c;k+=1){if(M[k]<0)continue;const W=P[k],Y=C[k],Q=W+L[k],ne=Y+w[k],z=W+F[k],$=Y+N[k],J=Math.min(W,Q,z),se=Math.max(W,Q,z),re=Math.min(Y,ne,$),le=Math.max(Y,ne,$),ae=O(J),ce=O(se),ue=X(re),de=X(le);for(let ee=ue;ee<=de;ee+=1){const he=ee*v;for(let pe=ae;pe<=ce;pe+=1){const Se=he+pe;T[R[Se]++]=k}}}return{xMin:r,xMax:l,zMin:d,zMax:h,cellSize:b,nx:v,nz:g,offsets:S,indices:T,ia:M,ib:I,ic:x,ax:P,az:C,v0x:L,v0z:w,v1x:F,v1z:N,invDenom:D,avgEdgeLength:m}}function _r(e,t,n,o){if(t.length===0||e.ia.length===0)return 0;const a=Jo(n,e.xMin,e.xMax),i=Jo(o,e.zMin,e.zMax),c=dn(Math.floor((a-e.xMin)/e.cellSize),0,e.nx-1),l=dn(Math.floor((i-e.zMin)/e.cellSize),0,e.nz-1)*e.nx+c,d=e.offsets[l],h=e.offsets[l+1];for(let p=d;p<h;p+=1){const f=e.indices[p],m=e.invDenom[f];if(m===0)continue;const y=a-e.ax[f],b=i-e.az[f],v=(y*e.v1z[f]-b*e.v1x[f])*m,g=(e.v0x[f]*b-e.v0z[f]*y)*m,A=1-v-g;if(A>=-1e-9&&v>=-1e-9&&g>=-1e-9){const M=e.ia[f],I=e.ib[f],x=e.ic[f];return t[M]*A+t[I]*v+t[x]*g}}for(let p=0;p<e.ia.length;p+=1){const f=e.invDenom[p];if(f===0)continue;const m=a-e.ax[p],y=i-e.az[p],b=(m*e.v1z[p]-y*e.v1x[p])*f,v=(e.v0x[p]*y-e.v0z[p]*m)*f,g=1-b-v;if(g>=-1e-9&&b>=-1e-9&&v>=-1e-9){const A=e.ia[p],M=e.ib[p],I=e.ic[p];return t[A]*g+t[M]*b+t[I]*v}}return 0}const ei="webgpu-failure-banner",ti=e=>{if(e instanceof Error){const t=e.message||e.name;return t?`${e.name}: ${t}`:e.name}try{return typeof e=="string"?e:JSON.stringify(e)}catch{return String(e)}};function Ur(e){console.error("[webgpu] failure",e.operation,e.error);const t=document.getElementById(ei);if(t){const l=t.querySelector(".webgpu-banner__details");if(l){const d=["WebGPU call failed.",`Operation: ${e.operation}`,e.hint?`Hint: ${e.hint}`:null,`Error: ${ti(e.error)}`].filter(Boolean);l.textContent=d.join(`
`)}t.classList.add("visible");return}const n=document.createElement("div");n.id=ei,n.className="webgpu-banner visible",n.setAttribute("role","alert");const o=document.createElement("div");o.className="webgpu-banner__body";const a=document.createElement("div");a.className="webgpu-banner__title",a.textContent="WebGPU call failed";const i=document.createElement("pre");i.className="webgpu-banner__details";const c=["WebGPU call failed.",`Operation: ${e.operation}`,e.hint?`Hint: ${e.hint}`:null,`Error: ${ti(e.error)}`,"This device/browser may not fully support WebGPU."].filter(Boolean);i.textContent=c.join(`
`),o.append(a,i);const r=document.createElement("button");r.className="webgpu-banner__close",r.type="button",r.textContent="Dismiss",r.addEventListener("click",()=>{n.classList.remove("visible")}),n.append(o,r),document.body.appendChild(n)}const Dr=`// MSDF-based text rendering adapted from the WebGPU samples (textRenderingMsdf).
// Extended with optional outline + background rendering for better readability.

// Glyph quad positions (x in [0..1], y in [-1..0]) so that BMFont y-offset math maps naturally.
const glyphPos = array(vec2f(0.0, -1.0), vec2f(1.0, -1.0), vec2f(0.0, 0.0), vec2f(1.0, 0.0));

struct VertexInput {
  @builtin(vertex_index) vertex : u32,
  @builtin(instance_index) instance : u32,
};

struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(0) texcoord : vec2f,
  @location(1) localPos : vec2f,
  @location(2) mode : f32,
};

struct Char {
  texOffset: vec2f,
  texExtent: vec2f,
  size: vec2f,
  offset: vec2f,
};

struct FormattedText {
  transform: mat4x4f,
  color: vec4f,
  outlineColor: vec4f,
  bgColor: vec4f,
  // params = (scale, outlinePx, bgPaddingPx, bgRadiusPx)
  params: vec4f,
  // sdfParams = (paddingRatio, distanceRange, _, _)
  sdfParams: vec4f,
  // bounds = (minX, minY, maxX, maxY) in text-space pixels (before scale)
  bounds: vec4f,
  chars: array<vec3f>,
};

struct Camera {
  projection: mat4x4f,
  view: mat4x4f,
};

// Font bindings
@group(0) @binding(0) var fontTexture: texture_2d<f32>;
@group(0) @binding(1) var fontSampler: sampler;
@group(0) @binding(2) var<storage> chars: array<Char>;

// Text bindings
@group(1) @binding(0) var<uniform> camera: Camera;
@group(1) @binding(1) var<storage> text: FormattedText;

fn sampleMsdf(texcoord: vec2f) -> f32 {
  let c = textureSample(fontTexture, fontSampler, texcoord);
  // Median of RGB distances for multi-channel SDF.
  return max(min(c.r, c.g), min(max(c.r, c.g), c.b));
}

// Signed distance to a rounded rectangle centered at the origin.
fn sdRoundRect(p: vec2f, halfSize: vec2f, radius: f32) -> f32 {
  // IQ's SDF: https://iquilezles.org/articles/distfunctions2d/
  let q = abs(p) - (halfSize - vec2f(radius));
  return length(max(q, vec2f(0.0))) + min(max(q.x, q.y), 0.0) - radius;
}

@vertex
fn vertexMain(input : VertexInput) -> VertexOutput {
  let entry = text.chars[input.instance];
  let isBackground = entry.z < 0.0;
  let scale = text.params.x;

  var output : VertexOutput;
  output.mode = select(0.0, 1.0, isBackground);

  if (isBackground) {
    let pad = text.params.z;
    let bounds = vec4f(text.bounds.xy - vec2f(pad), text.bounds.zw + vec2f(pad));

    // Map glyphPos from y in [-1..0] into uv in [0..1] for bounds interpolation.
    let uv = glyphPos[input.vertex] + vec2f(0.0, 1.0);
    let local = vec2f(mix(bounds.x, bounds.z, uv.x), mix(bounds.y, bounds.w, uv.y));

    output.localPos = local;
    output.texcoord = uv;
    output.position = camera.projection * camera.view * text.transform * vec4f(local * scale, 0.0, 1.0);
    return output;
  }

  let ch = chars[u32(entry.z)];
  let charPos = (glyphPos[input.vertex] * ch.size + entry.xy + ch.offset) * scale;

  output.position = camera.projection * camera.view * text.transform * vec4f(charPos, 0.0, 1.0);
  output.localPos = charPos;

  output.texcoord = glyphPos[input.vertex] * vec2f(1.0, -1.0);
  output.texcoord *= ch.texExtent;
  output.texcoord += ch.texOffset;
  return output;
}

@fragment
fn fragmentMain(input : VertexOutput) -> @location(0) vec4f {
  // WebGPU requires derivatives (\`dpdx\`, \`dpdy\`, \`fwidth\`) to be called in uniform control flow.
  // We draw background + glyphs in a single instanced draw, so we compute both paths
  // unconditionally and select the result by \`input.mode\` (per-instance constant).
  let bgMask = select(0.0, 1.0, input.mode > 0.5);

  // Background (optional).
  let pad = text.params.z;
  let bounds = vec4f(text.bounds.xy - vec2f(pad), text.bounds.zw + vec2f(pad));
  let center = (bounds.xy + bounds.zw) * 0.5;
  let halfSize = (bounds.zw - bounds.xy) * 0.5;
  let radius = max(0.0, min(text.params.w, min(halfSize.x, halfSize.y)));

  let dist = sdRoundRect(input.localPos - center, halfSize, radius);
  let aa = max(1e-6, fwidth(dist));
  let bgAlpha = smoothstep(aa, 0.0, dist);
  let bgA = text.bgColor.a * bgAlpha;
  let bgPremul = text.bgColor.rgb * bgA;

  // Glyph.
  // AA technique from Paul Houx: https://github.com/Chlumsky/msdfgen/issues/22#issuecomment-234958005
  let pxRange = max(text.sdfParams.y, 1e-6);
  let paddingRatio = clamp(text.sdfParams.x, 0.0, 1.0);
  let sz = vec2f(textureDimensions(fontTexture, 0));
  let dx = sz.x * length(vec2f(dpdxFine(input.texcoord.x), dpdyFine(input.texcoord.x)));
  let dy = sz.y * length(vec2f(dpdxFine(input.texcoord.y), dpdyFine(input.texcoord.y)));
  // Clamp the screen-space range so that very small glyphs don't turn into semi-transparent quads
  // (minification can make \`toPixels < 1\`, which prevents \`pxDist\` from reaching the full [-0.5..0.5] range).
  let toPixels = max(pxRange * inverseSqrt(dx * dx + dy * dy), 1.0);
  let sigDist = sampleMsdf(input.texcoord) - 0.5;
  let pxDist = sigDist * toPixels;

  let edgeWidth = 0.5;
  let fillAlpha = smoothstep(-edgeWidth, edgeWidth, pxDist);

  // Clamp outline thickness to the available padding so small glyphs don't fill the quad.
  let maxOutlinePx = max(0.0, toPixels * paddingRatio - edgeWidth);
  let outlinePx = min(max(0.0, text.params.y), maxOutlinePx);
  var outlineAlpha = 0.0;
  if (outlinePx > 0.0) {
    // Outside-only stroke: smooth outer edge at (-outlinePx), then fade into the fill edge at 0.
    let outer = smoothstep(-outlinePx - edgeWidth, -outlinePx + edgeWidth, pxDist);
    outlineAlpha = max(0.0, outer - fillAlpha);
  }

  let fillA = text.color.a * fillAlpha;
  let outlineA = text.outlineColor.a * outlineAlpha;
  let outA = fillA + outlineA * (1.0 - fillA);
  let glyphPremul = text.color.rgb * fillA + text.outlineColor.rgb * outlineA * (1.0 - fillA);

  let finalA = bgA * bgMask + outA * (1.0 - bgMask);
  if (finalA < 0.001) {
    discard;
  }
  let finalPremul = bgPremul * bgMask + glyphPremul * (1.0 - bgMask);
  return vec4f(finalPremul, finalA);
}
`,rn=40,Bn=4;class Gr{constructor(t,n,o,a,i,c,r){j(this,"charCount");j(this,"defaultChar");j(this,"paddingRatio");j(this,"distanceRange");this.pipeline=t,this.bindGroup=n,this.lineHeight=o,this.chars=a,this.kernings=i;const l=Object.values(a);this.charCount=l.length,this.defaultChar=l[0],this.distanceRange=c,this.paddingRatio=r}getChar(t){return this.chars[t]??this.defaultChar}getXAdvance(t,n=-1){const o=this.getChar(t);if(n>=0){const a=this.kernings.get(t);if(a)return o.xadvance+(a.get(n)??0)}return o.xadvance}}class Vr{constructor(t,n,o,a,i,c){j(this,"headerArray",new Float32Array(rn));j(this,"headerDirty",!0);this.device=t,this.renderBundle=n,this.measurements=o,this.font=a,this.textBuffer=i,this.headerArray.set(c),this.headerDirty=!1}getRenderBundle(){return this.headerDirty&&(this.headerDirty=!1,this.device.queue.writeBuffer(this.textBuffer,0,this.headerArray.buffer,this.headerArray.byteOffset,this.headerArray.byteLength)),this.renderBundle}setTransform(t){this.headerArray.set(t,0),this.headerDirty=!0}setColor(t,n,o,a=1){this.headerArray[16]=t,this.headerArray[17]=n,this.headerArray[18]=o,this.headerArray[19]=a,this.headerDirty=!0}setOutline(t,n,o,a,i=1){this.headerArray[20]=n,this.headerArray[21]=o,this.headerArray[22]=a,this.headerArray[23]=i,this.headerArray[29]=t,this.headerDirty=!0}setBackground(t,n,o,a,i,c=0){this.headerArray[24]=o,this.headerArray[25]=a,this.headerArray[26]=i,this.headerArray[27]=c,this.headerArray[30]=t,this.headerArray[31]=n,this.headerDirty=!0}setPixelScale(t){this.headerArray[28]=t,this.headerDirty=!0}getPixelScale(){return this.headerArray[28]}getBackgroundPaddingPx(){return this.headerArray[30]}getBoundsPx(){return{minX:this.headerArray[36],minY:this.headerArray[37],maxX:this.headerArray[38],maxY:this.headerArray[39]}}}class Or{constructor(t,n,o){j(this,"fontBindGroupLayout");j(this,"textBindGroupLayout");j(this,"pipelinePromise");j(this,"sampler");j(this,"cameraUniformBuffer");j(this,"renderBundleDescriptor");j(this,"cameraArray",new Float32Array(16*2));this.device=t,this.renderBundleDescriptor={colorFormats:[n],depthStencilFormat:o},this.sampler=t.createSampler({label:"MSDF text sampler",minFilter:"linear",magFilter:"linear",mipmapFilter:"linear",maxAnisotropy:16}),this.cameraUniformBuffer=t.createBuffer({label:"MSDF camera uniform buffer",size:this.cameraArray.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.fontBindGroupLayout=t.createBindGroupLayout({label:"MSDF font bind group layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.textBindGroupLayout=t.createBindGroupLayout({label:"MSDF text bind group layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]});const a=t.createShaderModule({label:"MSDF text shader",code:Dr});this.pipelinePromise=t.createRenderPipelineAsync({label:"msdf text pipeline",layout:t.createPipelineLayout({bindGroupLayouts:[this.fontBindGroupLayout,this.textBindGroupLayout]}),vertex:{module:a,entryPoint:"vertexMain"},fragment:{module:a,entryPoint:"fragmentMain",targets:[{format:n,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"},depthStencil:{depthWriteEnabled:!1,depthCompare:"less-equal",format:o}})}async loadTexture(t){const n=await fetch(t),o=await createImageBitmap(await n.blob()),a=this.device.createTexture({label:`MSDF font texture ${t}`,size:[o.width,o.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:o},{texture:a},[o.width,o.height]),a}async createFont(t){var x,P,C,L;const n=new URL(t,document.baseURI).toString(),a=await(await fetch(n)).json(),i=new URL(".",n).toString(),c=a.pages.map(w=>this.loadTexture(new URL(w,i).toString())),r=a.chars.length,l=Number.isFinite((x=a.distanceField)==null?void 0:x.distanceRange)?(P=a.distanceField)==null?void 0:P.distanceRange:4,d=Array.isArray((C=a.info)==null?void 0:C.padding)?((L=a.info)==null?void 0:L.padding)??[]:[];let h=Number.POSITIVE_INFINITY;for(const w of d)Number.isFinite(w)&&(h=Math.min(h,w));Number.isFinite(h)||(h=l);const p=l>0?Math.min(Math.max(h/l,0),1):1,f=this.device.createBuffer({label:"MSDF character layout buffer",size:r*Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0}),m=new Float32Array(f.getMappedRange()),y=1/a.common.scaleW,b=1/a.common.scaleH,v={};let g=0;for(const[w,F]of a.chars.entries()){const N={...F,charIndex:w};v[N.id]=N,m[g]=N.x*y,m[g+1]=N.y*b,m[g+2]=N.width*y,m[g+3]=N.height*b,m[g+4]=N.width,m[g+5]=N.height,m[g+6]=N.xoffset,m[g+7]=-N.yoffset,g+=8}f.unmap();const A=await Promise.all(c),M=this.device.createBindGroup({label:"msdf font bind group",layout:this.fontBindGroupLayout,entries:[{binding:0,resource:A[0].createView()},{binding:1,resource:this.sampler},{binding:2,resource:{buffer:f}}]}),I=new Map;if(a.kernings)for(const w of a.kernings){let F=I.get(w.first);F||(F=new Map,I.set(w.first,F)),F.set(w.second,w.amount)}return new Gr(await this.pipelinePromise,M,a.common.lineHeight,v,I,l,p)}formatText(t,n,o={}){const a=this.measureText(t,n),i=a.printedCharCount+1,c=new Float32Array(rn);c.set(Qe(),0);const r=o.color??[1,1,1,1];c[16]=r[0],c[17]=r[1],c[18]=r[2],c[19]=r[3];const l=o.outlineColor??[0,0,0,1];c[20]=l[0],c[21]=l[1],c[22]=l[2],c[23]=l[3];const d=o.backgroundColor??[0,0,0,0];c[24]=d[0],c[25]=d[1],c[26]=d[2],c[27]=d[3],c[28]=o.pixelScale??1/512,c[29]=o.outlinePx??0,c[30]=o.backgroundPaddingPx??0,c[31]=o.backgroundRadiusPx??0,c[32]=t.paddingRatio,c[33]=t.distanceRange,c[34]=0,c[35]=0;const h=this.device.createBuffer({label:"msdf text buffer",size:(rn+i*Bn)*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),p=new Float32Array(h.getMappedRange());p.set(c,0);let f=rn;p[f]=0,p[f+1]=0,p[f+2]=-1,f+=Bn;let m=Number.POSITIVE_INFINITY,y=Number.POSITIVE_INFINITY,b=Number.NEGATIVE_INFINITY,v=Number.NEGATIVE_INFINITY;const g=(x,P,C,L)=>{const w=!!o.centered,F=w?-.5*a.lineWidths[C]:0,N=w?a.height*.5:0,D=x+F,U=P+N;p[f]=D,p[f+1]=U,p[f+2]=L.charIndex,f+=Bn;const O=D+L.xoffset,X=O+L.width,S=U-L.yoffset,B=S-L.height;m=Math.min(m,O),b=Math.max(b,X),y=Math.min(y,B),v=Math.max(v,S)};this.measureText(t,n,g),Number.isFinite(m)||(m=0,y=0,b=0,v=0),p[36]=m,p[37]=y,p[38]=b,p[39]=v,c[36]=m,c[37]=y,c[38]=b,c[39]=v,h.unmap();const A=this.device.createBindGroup({label:"msdf text bind group",layout:this.textBindGroupLayout,entries:[{binding:0,resource:{buffer:this.cameraUniformBuffer}},{binding:1,resource:{buffer:h}}]}),M=this.device.createRenderBundleEncoder(this.renderBundleDescriptor);M.setPipeline(t.pipeline),M.setBindGroup(0,t.bindGroup),M.setBindGroup(1,A),M.draw(4,i);const I=M.finish();return new Vr(this.device,I,a,t,h,c)}measureText(t,n,o){let a=0;const i=[];let c=0,r=0,l=0,d=0,h=n.charCodeAt(0);for(let p=0;p<n.length;p+=1){const f=h;switch(h=p<n.length-1?n.charCodeAt(p+1):-1,f){case 10:i.push(c),l+=1,a=Math.max(a,c),c=0,r-=t.lineHeight;break;case 13:break;case 32:c+=t.getXAdvance(f,h);break;default:{const m=t.getChar(f);o==null||o(c,r,l,m),c+=t.getXAdvance(f,h),d+=1}}}return i.push(c),a=Math.max(a,c),{width:a,height:i.length*t.lineHeight,lineWidths:i,printedCharCount:d}}updateCamera(t,n){this.cameraArray.set(t,0),this.cameraArray.set(n,16),this.device.queue.writeBuffer(this.cameraUniformBuffer,0,this.cameraArray.buffer,this.cameraArray.byteOffset,this.cameraArray.byteLength)}render(t,...n){const o=n.map(a=>a.getRenderBundle());t.executeBundles(o)}}const Yr=`struct VertexIn {
  @location(0) position: vec2f,
  @location(1) color: vec4f,
  // Segment endpoints in device pixels (same coordinate system as fragment @builtin(position)).
  @location(2) segA0: vec2f,
  @location(3) segB0: vec2f,
  @location(4) segA1: vec2f,
  @location(5) segB1: vec2f,
  @location(6) halfWidthPx: f32,
};

struct VertexOut {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
  @location(1) @interpolate(flat) segA0: vec2f,
  @location(2) @interpolate(flat) segB0: vec2f,
  @location(3) @interpolate(flat) segA1: vec2f,
  @location(4) @interpolate(flat) segB1: vec2f,
  @location(5) @interpolate(flat) halfWidthPx: f32,
};

@vertex
fn vsMain(input: VertexIn) -> VertexOut {
  var out: VertexOut;
  out.position = vec4f(input.position, 0.0, 1.0);
  out.color = input.color;
  out.segA0 = input.segA0;
  out.segB0 = input.segB0;
  out.segA1 = input.segA1;
  out.segB1 = input.segB1;
  out.halfWidthPx = input.halfWidthPx;
  return out;
}

fn sdSegment(p: vec2f, a: vec2f, b: vec2f) -> f32 {
  // Distance to a line segment (used as a capsule SDF for crisp, derivative-based AA).
  let pa = p - a;
  let ba = b - a;
  let denom = dot(ba, ba);
  if (denom < 1e-6) {
    return length(pa);
  }
  let h = clamp(dot(pa, ba) / denom, 0.0, 1.0);
  return length(pa - ba * h);
}

@fragment
fn fsMain(input: VertexOut) -> @location(0) vec4f {
  let p = input.position.xy;
  let dist0 = sdSegment(p, input.segA0, input.segB0);
  let dist1 = sdSegment(p, input.segA1, input.segB1);
  let dist = min(dist0, dist1) - input.halfWidthPx;
  let aa = max(0.5, fwidth(dist));
  let coverage = 1.0 - smoothstep(-aa, aa, dist);
  let outA = input.color.a * coverage;
  if (outA < 0.001) {
    discard;
  }
  return vec4f(input.color.rgb * coverage, outA);
}
`,tn=15,pt=4;function jr(e,t){let n=Math.max(e,256);for(;n<t;)n=Math.floor(n*1.5);return n}class Xr{constructor(t,n,o){j(this,"pipeline");j(this,"vertexBuffer");j(this,"vertexCapacityFloats",0);j(this,"vertexCount",0);this.device=t;const a=t.createShaderModule({label:"Screen line shader",code:Yr});this.pipeline=t.createRenderPipeline({label:"Screen line pipeline",layout:"auto",vertex:{module:a,entryPoint:"vsMain",buffers:[{arrayStride:tn*pt,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:2*pt,format:"float32x4"},{shaderLocation:2,offset:6*pt,format:"float32x2"},{shaderLocation:3,offset:8*pt,format:"float32x2"},{shaderLocation:4,offset:10*pt,format:"float32x2"},{shaderLocation:5,offset:12*pt,format:"float32x2"},{shaderLocation:6,offset:14*pt,format:"float32"}]}]},fragment:{module:a,entryPoint:"fsMain",targets:[{format:n,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!1,depthCompare:"always",format:o}}),this.vertexBuffer=t.createBuffer({label:"Screen line vertex buffer (empty)",size:tn*pt,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.vertexCapacityFloats=tn}update(t){const n=t.length;if(this.vertexCount=n>0?Math.floor(n/tn):0,this.vertexCount!==0){if(n>this.vertexCapacityFloats){const o=jr(this.vertexCapacityFloats,n);this.vertexBuffer.destroy(),this.vertexBuffer=this.device.createBuffer({label:"Screen line vertex buffer",size:o*pt,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.vertexCapacityFloats=o}this.device.queue.writeBuffer(this.vertexBuffer,0,t.buffer,t.byteOffset,t.byteLength)}}render(t){this.vertexCount!==0&&(t.setPipeline(this.pipeline),t.setVertexBuffer(0,this.vertexBuffer),t.draw(this.vertexCount,1,0,0))}}const rt=1e-6,Wr=.01,ni=24,oi=12,On=10,vi=12,Mi=12,qr=8,$r=8,ii=16,si=12,ri=4,kn=.015,ai=10,ci=6,Hr=3,Kr=1.875,Qr=2,Yt=Qr*.5,Pi=1,Zr=.9,Ln=1,Rn=.5,li=.5,Jr=.5,Gt=128;function ea(e,t,n,o){return[e*o,t*o,n*o,o]}function ta(e){const t=e.getBoundsPx(),n=e.getBackgroundPaddingPx(),o=e.getPixelScale(),a=(t.minX-n)*o,i=(t.minY-n)*o,c=(t.maxX+n)*o,r=(t.maxY+n)*o;return{width:c-a,height:r-i,bgMinX:a,bgMinY:i}}function nt(e,t,n){return Math.max(t,Math.min(n,e))}function na(e,t){return!Number.isFinite(t)||t<=0?e:{minX:e.minX-t,minY:e.minY-t,maxX:e.maxX+t,maxY:e.maxY+t}}function oa(e,t){return{minX:nt(e.minX,0,t.width),minY:nt(e.minY,0,t.height),maxX:nt(e.maxX,0,t.width),maxY:nt(e.maxY,0,t.height)}}function ia(e,t,n,o,a){if(!Number.isFinite(e)||!Number.isFinite(t)||!Number.isFinite(n)||!Number.isFinite(o)||!Number.isFinite(a.minX)||!Number.isFinite(a.minY)||a.minX>a.maxX||a.minY>a.maxY)return!1;const i=(b,v)=>b>=a.minX&&b<=a.maxX&&v>=a.minY&&v<=a.maxY;if(i(e,t)||i(n,o))return!0;const c=Math.min(e,n),r=Math.max(e,n),l=Math.min(t,o),d=Math.max(t,o);if(r<a.minX||c>a.maxX||d<a.minY||l>a.maxY)return!1;let h=0,p=1;const f=n-e,m=o-t,y=(b,v)=>{if(Math.abs(b)<=rt)return v>=0;const g=v/b;if(b<0){if(g>p)return!1;h=Math.max(h,g)}else{if(g<h)return!1;p=Math.min(p,g)}return h<=p};return y(-f,e-a.minX)&&y(f,a.maxX-e)&&y(-m,t-a.minY)&&y(m,a.maxY-t)}function sa(e,t,n,o){if(n>o)return;let a=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let l=n;l<=o;l+=1)Number.isFinite(e[l])?(a=e[l],i=t[l]):Number.isFinite(a)&&(e[l]=a,t[l]=i);let c=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let l=o;l>=n;l-=1)Number.isFinite(e[l])?(c=e[l],r=t[l]):Number.isFinite(c)&&(e[l]=c,t[l]=r)}function ra(e,t,n,o,a,i,c,r,l,d){if(c>r)return!1;const h=Math.max(1,l.height),p=a.length,f=Math.min(t,o),m=Math.max(t,o),y=I=>{const x=nt(I,0,h),P=Math.floor(x/h*p);return Math.max(0,Math.min(p-1,P))};let b=y(f),v=y(m);if(b=Math.max(c,Math.min(r,b)),v=Math.max(c,Math.min(r,v)),b>v){const I=b;b=v,v=I}const g=n-e,A=o-t,M=h/p;if(Math.abs(A)<=rt){const I=y(t),x=a[I],P=i[I];if(!Number.isFinite(x)||!Number.isFinite(P))return!1;const C=Math.min(e,n);return Math.max(e,n)>=x-d&&C<=P+d}for(let I=b;I<=v;I+=1){const x=(I+.5)*M,C=(nt(x,f,m)-t)/A;if(C<0||C>1)continue;const L=e+g*C,w=a[I],F=i[I];if(!(!Number.isFinite(w)||!Number.isFinite(F))&&L>=w-d&&L<=F+d)return!0}return!1}function nn(e,t,n,o,a){const i=e,c=i[0]*t+i[4]*n+i[8]*o+i[12],r=i[1]*t+i[5]*n+i[9]*o+i[13],l=i[2]*t+i[6]*n+i[10]*o+i[14],d=i[3]*t+i[7]*n+i[11]*o+i[15];if(!Number.isFinite(d)||d<=0)return{x:0,y:0,depth:0,valid:!1};const h=c/d,p=r/d,f=l/d;if(!Number.isFinite(h)||!Number.isFinite(p))return{x:0,y:0,depth:0,valid:!1};const m=(h*.5+.5)*a.width,y=(1-(p*.5+.5))*a.height;return{x:m,y,depth:Number.isFinite(f)?f:0,valid:!0}}function aa(e){return .2126*e[0]+.7152*e[1]+.0722*e[2]>.6?[0,0,0,1]:[1,1,1,1]}function di(e,t,n,o,a,i,c){const r=Yt*c.dpr,d=(r+Pi)/Math.max(1e-6,c.dpr),h=o-t,p=a-n,f=Math.hypot(h,p);if(!Number.isFinite(f)||f<=rt)return;const m=h/f,y=p/f,b=-y,v=m,g=t-m*d,A=n-y*d,M=o+m*d,I=a+y*d,x=b*d,P=v*d,C=g+x,L=A+P,w=g-x,F=A-P,N=M+x,D=I+P,U=M-x,O=I-P,X=z=>z/c.width*2-1,S=z=>1-z/c.height*2,[B,T,R,k]=i,W=t*c.dpr,Y=n*c.dpr,Q=o*c.dpr,ne=a*c.dpr;e.push(X(C),S(L),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r),e.push(X(w),S(F),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r),e.push(X(N),S(D),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r),e.push(X(N),S(D),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r),e.push(X(w),S(F),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r),e.push(X(U),S(O),B,T,R,k,W,Y,Q,ne,W,Y,Q,ne,r)}function ca(e,t,n,o,a,i,c,r,l){const d=Yt*l.dpr,p=(d+Pi)/Math.max(1e-6,l.dpr);if(!Number.isFinite(t)||!Number.isFinite(n)||!Number.isFinite(o)||!Number.isFinite(a)||!Number.isFinite(i)||!Number.isFinite(c))return;const f=Math.min(t,o,i)-p,m=Math.max(t,o,i)+p,y=Math.min(n,a,c)-p,b=Math.max(n,a,c)+p,v=Q=>Q/l.width*2-1,g=Q=>1-Q/l.height*2,[A,M,I,x]=r,P=l.dpr,C=t*P,L=n*P,w=o*P,F=a*P,N=o*P,D=a*P,U=i*P,O=c*P,X=f,S=y,B=f,T=b,R=m,k=b,W=m,Y=y;e.push(v(X),g(S),A,M,I,x,C,L,w,F,N,D,U,O,d),e.push(v(B),g(T),A,M,I,x,C,L,w,F,N,D,U,O,d),e.push(v(R),g(k),A,M,I,x,C,L,w,F,N,D,U,O,d),e.push(v(X),g(S),A,M,I,x,C,L,w,F,N,D,U,O,d),e.push(v(R),g(k),A,M,I,x,C,L,w,F,N,D,U,O,d),e.push(v(W),g(Y),A,M,I,x,C,L,w,F,N,D,U,O,d)}function _n(e,t){e.sort((i,c)=>i.y0-c.y0||i.entry.order-c.entry.order);const n=vi,o=Math.max(n,t.height-Mi);for(const i of e)i.top=nt(i.top,n,Math.max(n,o-i.height));for(let i=1;i<e.length;i+=1){const c=e[i-1],r=e[i];r.top=Math.max(r.top,c.top+c.height+On)}const a=e[e.length-1];if(a&&a.top+a.height>o){a.top=Math.max(n,o-a.height);for(let i=e.length-2;i>=0;i-=1){const c=e[i+1],r=e[i];r.top=Math.min(r.top,c.top-r.height-On),r.top=nt(r.top,n,Math.max(n,o-r.height))}}}class la{constructor(t,n,o,a,i,c,r,l){j(this,"entries",[]);j(this,"ortho",Qe());j(this,"identity",Qe());j(this,"tmpMatrix",Qe());j(this,"lineRenderer");j(this,"unifiedSide",null);j(this,"silhouetteMinXByBin",new Float32Array(Gt));j(this,"silhouetteMaxXByBin",new Float32Array(Gt));this.textRenderer=t,this.font=n,this.model=o,this.geometryBySoilId=c,this.lineRenderer=new Xr(this.textRenderer.device,r,l);const d=new Map;for(const m of a){if(m.objectType!=="solid"&&m.objectType!=="solidWireframe"&&m.objectType!=="solidEdge"||!m.soilId)continue;const y=d.get(m.soilId)??[];y.push(m),d.set(m.soilId,y)}const{verticesXZ:h}=o.mesh,p=Math.floor(h.length/2);let f=0;for(const m of o.solids){const y=d.get(m.soilId);if(!y||y.length===0){f+=1;continue}const b=o.surfaces[m.top],v=o.surfaces[m.bottom];if(!b||!v||b.length!==p||v.length!==p){f+=1;continue}const g=i.get(m.soilId),A=(g==null?void 0:g.color)??[0,0,0],M=aa(A),I=this.textRenderer.formatText(this.font,m.name,{centered:!1,pixelScale:.32,color:M,outlinePx:6,outlineColor:[0,0,0,.85],backgroundColor:[A[0],A[1],A[2],.85],backgroundPaddingPx:12,backgroundRadiusPx:10}),x=ta(I);this.entries.push({solid:m,objects:y,text:I,textBox:x,leaderRgb:[A[0],A[1],A[2]],side:"left",order:f}),f+=1}}render(t,n,o,a){var ne;if(this.entries.length===0)return;const i=n.getViewProjMatrix(),c=rt,r=Math.max(c,((ne=this.model.solidOutlines)==null?void 0:ne.threshold)??Wr);let l=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,p=Number.NEGATIVE_INFINITY;const f=this.silhouetteMinXByBin,m=this.silhouetteMaxXByBin;f.fill(Number.POSITIVE_INFINITY),m.fill(Number.NEGATIVE_INFINITY);let y=Gt,b=-1;const v=1/Math.max(1,o.height),g=z=>{const $=nt(z,0,o.height),J=Math.floor($*v*Gt);return Math.max(0,Math.min(Gt-1,J))},A=z=>{const $=g(z.y),J=nt(z.x,0,o.width);f[$]=Math.min(f[$],J),m[$]=Math.max(m[$],J),y=Math.min(y,$),b=Math.max(b,$)},M=[];for(const z of this.entries){if(!z.objects.some(Ue=>Ue.visible&&(Ue.objectType==="solid"||Ue.objectType==="solidWireframe")&&Ue.mesh.vertexCount>0))continue;const J=this.geometryBySoilId.get(z.solid.soilId),se=(J==null?void 0:J.verticesXZ)??this.model.mesh.verticesXZ,re=(J==null?void 0:J.top)??this.model.surfaces[z.solid.top],le=(J==null?void 0:J.bottom)??this.model.surfaces[z.solid.bottom];if(!re||!le)continue;const ae=Math.floor(se.length/2);if(ae<3||re.length!==ae||le.length!==ae)continue;const ce=z.objects[0],ue=ce.modelMatrix[12],de=ce.modelMatrix[13],ee=ce.modelMatrix[14];let he=Number.POSITIVE_INFINITY,pe=0,Se=0,Ie=Number.NEGATIVE_INFINITY,Be=0,De=0,Ge=Number.POSITIVE_INFINITY,_e=0,H=0,je=Number.NEGATIVE_INFINITY,Ce=0,it=0;for(let Ue=0;Ue<ae;Ue+=1){const Ve=re[Ue],Ze=le[Ue];if(!Number.isFinite(Ve)||!Number.isFinite(Ze))continue;const Je=Ve-Ze;if(!Number.isFinite(Je)||Je<=c)continue;const zt=se[Ue*2],ie=se[Ue*2+1],yt=zt+ue,ct=ie+ee,et=nn(i,yt,Ve+de,ct,o);et.valid&&(l=Math.min(l,et.x),d=Math.max(d,et.x),h=Math.min(h,et.y),p=Math.max(p,et.y),A(et));const tt=nn(i,yt,Ze+de,ct,o);tt.valid&&(l=Math.min(l,tt.x),d=Math.max(d,tt.x),h=Math.min(h,tt.y),p=Math.max(p,tt.y),A(tt));const ht=.5*(Ve+Ze),ke=nn(i,yt,ht+de,ct,o);ke.valid&&(ke.x<Ge&&(Ge=ke.x,_e=ke.y,H=ke.depth),ke.x>je&&(je=ke.x,Ce=ke.y,it=ke.depth),!(Je<=r)&&(ke.x<he&&(he=ke.x,pe=ke.y,Se=ke.depth),ke.x>Ie&&(Ie=ke.x,Be=ke.y,De=ke.depth)))}(!Number.isFinite(he)||!Number.isFinite(Ie))&&(he=Ge,pe=_e,Se=H,Ie=je,Be=Ce,De=it),!(!Number.isFinite(he)||!Number.isFinite(Ie))&&M.push({entry:z,verticesXZ:se,top:re,bottom:le,vertexCount2d:ae,offsetX:ue,offsetY:de,offsetZ:ee,minMidX:he,minMidY:pe,minMidDepth:Se,maxMidX:Ie,maxMidY:Be,maxMidDepth:De})}if(!Number.isFinite(l)||!Number.isFinite(h)||M.length===0)return;b>=0&&y<=b&&sa(f,m,y,b);const I=oa({minX:l,minY:h,maxX:d,maxY:p},o),x=nt(l-oi,0,o.width),P=nt(d+oi,0,o.width),C=x-ni,L=P+ni,w=(a==null?void 0:a.uiRightLimitPx)??o.width-$r,F=[],N=[],D=(z,$)=>{const J=$==="left"?z.minMidX:z.maxMidX,se=$==="left"?J+ri:J-ri,re=$==="left"?z.minMidY:z.maxMidY,le=$==="left"?z.minMidDepth:z.maxMidDepth;if(!Number.isFinite(J)||!Number.isFinite(re))return{x:0,y:0,depth:0,valid:!1};let ae=0,ce=0,ue=0,de=0;const ee=he=>{for(let pe=0;pe<z.vertexCount2d;pe+=1){const Se=z.top[pe],Ie=z.bottom[pe];if(!Number.isFinite(Se)||!Number.isFinite(Ie))continue;const Be=Se-Ie;if(!Number.isFinite(Be)||Be<=he)continue;const De=z.verticesXZ[pe*2],Ge=z.verticesXZ[pe*2+1],_e=De+z.offsetX,H=Ge+z.offsetZ,je=.5*(Se+Ie),Ce=nn(i,_e,je+z.offsetY,H,o);Ce.valid&&($==="left"?Ce.x<=se:Ce.x>=se)&&(ae+=Ce.x,ce+=Ce.y,ue+=Ce.depth,de+=1)}};return ee(r),de===0&&r>c+rt&&ee(c),de===0?{x:J,y:re,depth:Number.isFinite(le)?le:0,valid:!0}:{x:ae/de,y:ce/de,depth:ue/de,valid:!0}},U=[];for(const z of M){const $=z.entry,J=$.textBox.width,se=$.textBox.height,re=D(z,"left"),le=D(z,"right"),ae=z.maxMidX-z.minMidX,ce=re.valid?re.x-l:Number.POSITIVE_INFINITY,ue=le.valid?d-le.x:Number.POSITIVE_INFINITY,de=re.valid&&ae>=si&&ce<=ii,ee=le.valid&&ae>=si&&ue<=ii,he=C-J>=qr,pe=L+J<=w;!he&&!pe||U.push({scratch:z,entry:$,width:J,height:se,leftAnchor:re,rightAnchor:le,leftValid:de,rightValid:ee,leftFits:he,rightFits:pe})}if(U.length===0)return;const O=Math.max(0,o.height-vi-Mi),S=U.reduce((z,$)=>z+$.height,0)+On*Math.max(0,U.length-1)<=O+rt,B=S&&U.every(z=>z.leftFits&&(z.leftValid||!z.rightValid)),T=S&&U.every(z=>z.rightFits&&(z.rightValid||!z.leftValid));let R=null;if(B||T)if(B&&T){const z=U.some(ce=>ce.entry.objects.some(ue=>ue.visible&&ue.objectType==="solidEdge")),$=Yt+Jr+(z?Ln+Rn:0),J=na(I,$),se=(ce,ue,de,ee)=>ia(ce,ue,de,ee,J)?ra(ce,ue,de,ee,f,m,y,b,o,$):!1,re=ce=>{const ue=[];for(const ee of U){const he=ce==="left"?ee.leftAnchor:ee.rightAnchor;if(!he.valid)continue;const pe=ce==="left"?C-ee.width:L;ue.push({entry:ee.entry,side:ce,anchor:he,y0:he.y,width:ee.width,height:ee.height,top:he.y-ee.height*.5,left:pe})}if(ue.length===0)return 0;_n(ue,o);let de=0;for(const ee of ue){const he=ee.top+ee.height*.5,pe=ee.side==="left"?1:-1,Ie=(ee.side==="left"?ee.left+ee.width:ee.left)+pe*ci,Be=Ie+pe*ai,De=ee.anchor.x-Be,Ge=ee.anchor.y-he,_e=Math.hypot(De,Ge);if(!Number.isFinite(_e)||_e<=rt)continue;const H=De/_e,je=Ge/_e,Ce=ee.entry.objects.some(Je=>Je.visible&&Je.objectType==="solidEdge"),it=Yt+li+(Ce?Ln+Rn:0),Ue=Math.min(it,_e-rt),Ve=ee.anchor.x-H*Ue,Ze=ee.anchor.y-je*Ue;(se(Ie,he,Be,he)||se(Be,he,Ve,Ze))&&(de+=1)}return de},le=re("left")>0,ae=re("right")>0;if(le!==ae)R=le?"right":"left";else{const ce=U.reduce((pe,Se)=>pe+Se.leftAnchor.depth,0)/U.length,ue=U.reduce((pe,Se)=>pe+Se.rightAnchor.depth,0)/U.length,de=ce<=ue?"left":"right",ee=de==="left"?"right":"left",he=Math.abs(ce-ue);this.unifiedSide===ee&&he<=kn?R=ee:R=de}}else R=B?"left":"right";this.unifiedSide=R;const k=z=>{const $=z.leftValid&&z.leftFits,J=z.rightValid&&z.rightFits;if($&&J){const se=z.leftAnchor.depth<=z.rightAnchor.depth?"left":"right";return Math.abs(z.leftAnchor.depth-z.rightAnchor.depth)>kn?se:z.entry.side}if(z.entry.side==="left"&&$)return"left";if(z.entry.side==="right"&&J)return"right";if($)return"left";if(J)return"right";if(z.entry.side==="left"&&z.leftFits)return"left";if(z.entry.side==="right"&&z.rightFits)return"right";if(z.leftFits&&z.rightFits){const se=z.leftAnchor.depth<=z.rightAnchor.depth?"left":"right";if(Math.abs(z.leftAnchor.depth-z.rightAnchor.depth)>kn)return se}return z.leftFits?"left":z.rightFits?"right":null};for(const z of U){const $=R??k(z);if(!$)continue;z.entry.side=$;const J=$==="left"?z.leftAnchor:z.rightAnchor;if(!J.valid)continue;const se=$==="left"?C-z.width:L,re=J.y,le=re-z.height*.5,ae={entry:z.entry,side:$,anchor:J,y0:re,width:z.width,height:z.height,top:le,left:se};$==="left"?F.push(ae):N.push(ae)}if(F.length===0&&N.length===0)return;_n(F,o),_n(N,o),fi(this.ortho,0,o.width,0,o.height,0,1),this.textRenderer.updateCamera(this.ortho,this.identity);const W=[],Y=[],Q=z=>{const $=z.left,J=z.top,se=o.height-(J+z.height),re=$-z.entry.textBox.bgMinX,le=se-z.entry.textBox.bgMinY;hi(this.tmpMatrix),this.tmpMatrix[12]=re,this.tmpMatrix[13]=le,this.tmpMatrix[14]=0,z.entry.text.setTransform(this.tmpMatrix),Y.push(z.entry.text);const ae=J+z.height*.5,ce=z.side==="left"?1:-1,de=(z.side==="left"?$+z.width:$)+ce*ci,ee=de+ce*ai,he=z.entry.leaderRgb,pe=ea(he[0],he[1],he[2],Zr),Se=z.anchor.x-ee,Ie=z.anchor.y-ae,Be=Math.hypot(Se,Ie);if(!Number.isFinite(Be)||Be<=rt)return;const De=Se/Be,Ge=Ie/Be,_e=z.entry.objects.some(ke=>ke.visible&&ke.objectType==="solidEdge"),H=Yt+li+(_e?Ln+Rn:0),je=Math.min(H,Be-rt),Ce=z.anchor.x-De*je,it=z.anchor.y-Ge*je;ca(W,de,ae,ee,ae,Ce,it,pe,o);const Ue=Be-je,Ve=Math.min(Hr,Ue*.5);if(Ve<=rt)return;const Ze=Math.min(Kr,Ve*.9),Je=Ce-De*Ve,zt=it-Ge*Ve,ie=-Ge,yt=De,ct=Je+ie*Ze,et=zt+yt*Ze,tt=Je-ie*Ze,ht=zt-yt*Ze;di(W,Ce,it,ct,et,pe,o),di(W,Ce,it,tt,ht,pe,o)};for(const z of F)Q(z);for(const z of N)Q(z);this.lineRenderer.update(new Float32Array(W)),this.lineRenderer.render(t),Y.length>0&&this.textRenderer.render(t,...Y)}}const on=document.querySelector("#gfx"),Un=document.querySelector("#message"),Ke=new ps(Ur),Lt={target:[12.308137893676758,-2.078213691711426,-.03483019769191742],yaw:2.59007353266014,pitch:.3322148625050682,distance:34.27910453694887,orthoScale:14.198870005209317,mode:"perspective"};function da(e){Un&&(Un.textContent=e,Un.classList.add("visible"))}function ha(e){e.mode=Lt.mode,e.orthoScale=Lt.orthoScale,e.distance=Lt.distance,e.setAngles(Lt.yaw,Lt.pitch),Ct(e.target,...Lt.target)}async function fa(e){try{const t=await fetch(e);if(!t.ok)return null;const n=await t.json();return!n||n.version!==2?null:n}catch{return null}}async function ua(){if(!on)throw new Error("Canvas element not found.");let e,t,n;try{({device:e,context:t,format:n}=await us(on,Ke))}catch(v){Ke.hasFailed()||Ke.fail("initWebGPU",v);return}let o;try{o=Ke.call("Renderer.constructor",()=>new Ds(on,e,t,n,Ke))}catch{return}let a=null,i=null;try{const v="depth24plus";a=new Or(e,n,v),i=await a.createFont("./assets/font/ya-hei-ascii-msdf.json")}catch(v){console.warn("MSDF font init failed:",v),a=null,i=null}const c=new Cs;new Fs(on,c);const l=await Gs("./scene.json"),d=await fa("./solids_model_v2.json");Nr(l),d&&(Cr(d),l.solidsModel=d);const h=Fr.sections??[],p=Ar(h);if(p.length>0){const v=new Map(p.map(M=>[M.id,M])),g=[],A=new Set;if(l.sections)for(const M of l.sections){const I=v.get(M.id),x=M.path.length>0?M.path:(I==null?void 0:I.worldPath)??[];g.push({...M,path:x,vector:I}),A.add(M.id)}for(const M of p)A.has(M.id)||g.push({id:M.id,name:M.name,path:M.worldPath,vector:M});l.sections=g}let f;try{f=Ke.call("buildScene",()=>pr(e,o,l))}catch{return}o.setObjects(f.objects);const m=()=>{if(Ke.hasFailed())return;try{o.resize()}catch(A){Ke.hasFailed()||Ke.fail("Renderer.resize",A);return}const{width:v,height:g}=o.getSize();c.setAspect(v/g)};m(),ha(c);const y=pa(e,n,l,f.objects,o,c,f.bounds,Ke,a,i);document.body.classList.add("ready"),window.addEventListener("resize",m);const b=()=>{if(!Ke.hasFailed()){try{o.render(c)}catch(v){Ke.hasFailed()||Ke.fail("Renderer.render",v);return}y==null||y(),requestAnimationFrame(b)}};requestAnimationFrame(b)}function pa(e,t,n,o,a,i,c,r,l,d){var fo,uo,po,mo,go,xo,yo,bo,vo,Mo,Po,wo,Io,So,To,Eo,Ao,No,Co,zo,Fo,Bo,ko,Lo,Ro,_o;const h=document.querySelector("#panel");if(!h)return null;const p=document.querySelector("#panel-toggle"),f=document.querySelector("#panel-body"),m=Array.from(document.querySelectorAll("input[name='theme']")),y=document.querySelector("#toggle-terrain"),b=document.querySelector("#toggle-grid"),v=document.querySelector("#toggle-sections"),g=document.querySelector("#toggle-profiles"),A=document.querySelector("#toggle-solids"),M=Array.from(document.querySelectorAll("input[name='solids-visibility']")),I=Array.from(document.querySelectorAll("input[name='sections-visibility']")),x=document.querySelector("#toggle-solids-edges"),P=document.querySelector("#toggle-solids-labels"),C=document.querySelector("#fit-view"),L=document.querySelector("#toggle-projection"),w=Array.from(document.querySelectorAll("input[name='mode']")),F=Array.from(document.querySelectorAll(".panel-views button")),N=document.querySelector("#section-list"),D=document.querySelector("#profile-list"),U=document.querySelector("#solid-list"),O=document.querySelector("#solids-spacing"),X=document.querySelector("#solids-spacing-value"),S=document.querySelector("#solids-clip-x"),B=document.querySelector("#solids-clip-x-value"),T=document.querySelector("#solids-clip-y"),R=document.querySelector("#solids-clip-y-value"),k=document.querySelector("#solids-clip-z"),W=document.querySelector("#solids-clip-z-value"),Y=document.querySelector("#sections-controls"),Q=document.querySelector("#profiles-controls"),ne=document.querySelector("#solids-controls"),z=document.querySelector("#gfx"),$=document.querySelector("#section-detail"),J=document.querySelector("#section-title"),se=document.querySelector("#section-canvas"),re=document.querySelector("#section-close"),le=y==null?void 0:y.closest("label"),ae=b==null?void 0:b.closest("label");if(!y||!b||!v||!g||!A||M.length===0||I.length===0||!x||!P||!C||!L||!p||!f||m.length===0||w.length===0||!N||!D||!U||!O||!X||!S||!B||!T||!R||!k||!W||!Y||!Q||!ne||!$||!J||!se||!re||!le||!ae)return null;const ce=s=>{h.classList.toggle("panel--collapsed",s),p.setAttribute("aria-expanded",s?"false":"true")},ue=()=>{window.matchMedia("(max-width: 720px)").matches||ce(!1)};p.addEventListener("click",()=>{ce(!h.classList.contains("panel--collapsed"))}),window.addEventListener("resize",ue),ue(),document.addEventListener("pointerdown",s=>{if(!window.matchMedia("(max-width: 720px)").matches||h.classList.contains("panel--collapsed"))return;const u=s.target;u instanceof Node&&h.contains(u)||ce(!0)}),U.style.visibility="hidden";const de={dark:{clearColor:{r:21/255,g:21/255,b:21/255,a:1},sectionCanvasBg:"#111",sectionAxis:"rgba(255, 255, 255, 0.35)",sectionAxisTick:"rgba(255, 255, 255, 0.08)",sectionText:"rgba(230, 230, 230, 0.7)",sectionEmptyText:"#ccc",sectionHatch:"rgba(0, 0, 0, 0.85)",sectionPatchStroke:"rgba(0, 0, 0, 0.55)"},light:{clearColor:{r:1,g:1,b:1,a:1},sectionCanvasBg:"#fff",sectionAxis:"rgba(0, 0, 0, 0.35)",sectionAxisTick:"rgba(0, 0, 0, 0.08)",sectionText:"rgba(20, 20, 20, 0.7)",sectionEmptyText:"#333",sectionHatch:"rgba(0, 0, 0, 0.7)",sectionPatchStroke:"rgba(0, 0, 0, 0.35)"}};let ee=de.dark,he="dark";const pe=()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return"dark";try{return window.matchMedia("(prefers-color-scheme: light)").matches?"light":"dark"}catch{return"dark"}},Se=()=>{var u;return((u=m.find(E=>E.checked))==null?void 0:u.value)==="light"?"light":"dark"},Ie=s=>{document.documentElement.dataset.theme=s,he=s,ee=de[s],a.setClearColor(ee.clearColor),vn()},Be=()=>{var u;return((u=w.find(E=>E.checked))==null?void 0:u.value)==="solids"?"solids":"sections"},De=()=>{var u;const s=(u=M.find(E=>E.checked))==null?void 0:u.value;return s==="wireframe"||s==="transparent"||s==="classic"?s:"classic"},Ge=()=>{var u;const s=(u=I.find(E=>E.checked))==null?void 0:u.value;return s==="transparent"||s==="classic"||s==="wireframe"?s:"classic"},_e=s=>{const u=Number.parseFloat(O.max);return Number.isFinite(u)?Math.min(Math.max(0,s),u):Math.max(0,s)},H=(()=>{if(typeof window>"u")return{};const s=new URLSearchParams(window.location.search),u={},E=Ne=>{const be=s.get(Ne);return be===null?void 0:be},_=Ne=>{const be=s.get(Ne);if(be===null)return;const Pe=Number.parseFloat(be);return Number.isFinite(Pe)?Pe:void 0},V=Ne=>{const be=s.get(Ne);if(be===null)return;const Pe=be.trim().toLowerCase();if(Pe==="1"||Pe==="true"||Pe==="yes"||Pe==="on")return!0;if(Pe==="0"||Pe==="false"||Pe==="no"||Pe==="off")return!1},q=Ne=>{const be=E(Ne);if(be===void 0)return;const Pe=be.split(",").map($e=>$e.trim()).filter($e=>$e.length>0);return Pe.length>0?Pe:[]},Z=E("theme");(Z==="light"||Z==="dark")&&(u.theme=Z);const te=E("mode");(te==="sections"||te==="solids")&&(u.mode=te);const oe=V("panelCollapsed");oe!==void 0&&(u.panelCollapsed=oe);const ye={};for(const[Ne,be]of[["terrain","terrain"],["grid","grid"],["sections","sections"],["profiles","profiles"],["solids","solids"]]){const Pe=V(Ne);Pe!==void 0&&(ye[be]=Pe)}Object.keys(ye).length>0&&(u.visibility=ye);const me={},ge=q("solidsEnabled");ge!==void 0&&(me.enabled=ge);const fe=_("solidsSpacing");fe!==void 0&&(me.verticalSpacing=fe);const ve=E("solidsVis");(ve==="classic"||ve==="wireframe"||ve==="transparent")&&(me.displayMode=ve);const we=V("solidsEdges");we!==void 0&&(me.highlightEdges=we);const xe=V("solidsLabels");xe!==void 0&&(me.showLabels=xe);const Me=_("cropX");Me!==void 0&&(me.cropX=Me);const Te=_("cropY");Te!==void 0&&(me.cropY=Te);const K=_("cropZ");K!==void 0&&(me.cropZ=K),Object.keys(me).length>0&&(u.solids=me);const Ee={},Ae=E("sectionsVis");(Ae==="classic"||Ae==="transparent"||Ae==="wireframe")&&(Ee.displayMode=Ae),Object.keys(Ee).length>0&&(u.sections=Ee);const Re={},Oe=E("section");Oe!==void 0&&(Re.sectionId=Oe);const Fe=E("profile");Fe!==void 0&&(Re.profileId=Fe),Object.keys(Re).length>0&&(u.selection=Re);const qe={},St=E("camMode");St==="perspective"?qe.mode="perspective":(St==="orthographic"||St==="ortho"||St==="axonometric")&&(qe.mode="axonometric");const Tt=_("camYawDeg"),Qt=_("camYaw");Tt!==void 0?qe.yaw=Tt*Math.PI/180:Qt!==void 0&&(qe.yaw=Qt);const Zt=_("camPitchDeg"),Ut=_("camPitch");Zt!==void 0?qe.pitch=Zt*Math.PI/180:Ut!==void 0&&(qe.pitch=Ut);const Dt=_("camDist");Dt!==void 0&&(qe.distance=Dt);const Et=_("camOrtho");Et!==void 0&&(qe.orthoScale=Et);const At=E("camTarget");if(At!==void 0){const Ne=At.split(",").map(be=>Number.parseFloat(be.trim()));Ne.length>=3&&Ne.every(be=>Number.isFinite(be))&&(qe.target=[Ne[0],Ne[1],Ne[2]])}Object.keys(qe).length>0&&(u.camera=qe);const Nt={},vt=E("debugLabel");if(vt!==void 0){const Ne=vt.trim();Nt.label=Ne.length>0&&Ne!=="1"&&Ne.toLowerCase()!=="true"?Ne:"Label"}const Jt=V("debugLabelOnly");Jt!==void 0&&(Nt.labelOnly=Jt);const Mt=V("debugLabelNoBg");return Mt!==void 0&&(Nt.labelNoBg=Mt),Object.keys(Nt).length>0&&(u.debug=Nt),u})(),je=()=>{const s=Number.parseFloat(O.value);return Number.isFinite(s)?_e(s):0},Ce=s=>{const u=_e(s);O.value=u.toString(),G.solids.verticalSpacing=u,so()};H.panelCollapsed!==void 0&&ce(H.panelCollapsed),H.mode&&w.forEach(s=>{s.checked=s.value===H.mode}),H.visibility&&(H.visibility.terrain!==void 0&&(y.checked=H.visibility.terrain),H.visibility.grid!==void 0&&(b.checked=H.visibility.grid),H.visibility.sections!==void 0&&(v.checked=H.visibility.sections),H.visibility.profiles!==void 0&&(g.checked=H.visibility.profiles),H.visibility.solids!==void 0&&(A.checked=H.visibility.solids)),(fo=H.solids)!=null&&fo.displayMode&&M.forEach(s=>{var u;s.checked=s.value===((u=H.solids)==null?void 0:u.displayMode)}),(uo=H.sections)!=null&&uo.displayMode&&I.forEach(s=>{var u;s.checked=s.value===((u=H.sections)==null?void 0:u.displayMode)}),((po=H.solids)==null?void 0:po.highlightEdges)!==void 0&&(x.checked=H.solids.highlightEdges),((mo=H.solids)==null?void 0:mo.showLabels)!==void 0&&(P.checked=H.solids.showLabels),((go=H.solids)==null?void 0:go.verticalSpacing)!==void 0&&(O.value=_e(H.solids.verticalSpacing).toString());const it=$,Ue=J,Ve=se,Ze=re,Je=new Map(n.soils.map(s=>[s.id,s])),zt=new Map((n.sections??[]).map(s=>[s.id,s])),ie=n.solidsModel??null,yt=new Set(((ie==null?void 0:ie.solids)??[]).map(s=>s.soilId)),ct=new Map,et=new Map;for(const s of o)s.objectType!=="solid"||!s.soilId||et.set(s.soilId,s.layerIndex);let tt=0;for(const s of et.values())tt=Math.max(tt,s);const ht=ie&&l&&d?new la(l,d,ie,o,Je,ct,t,"depth24plus"):null,ke=ht?(s,u)=>{const{width:E,height:_,dpr:V}=a.getSize(),q={width:E/V,height:_/V,dpr:V},te=h.getBoundingClientRect().left-12;ht.render(s,u,q,{uiRightLimitPx:te})}:null,jn=((xo=H.debug)==null?void 0:xo.label)??((yo=H.debug)!=null&&yo.labelOnly||(bo=H.debug)!=null&&bo.labelNoBg?((vo=ie==null?void 0:ie.solids[0])==null?void 0:vo.name)??"Label":null),wi=((Mo=H.debug)==null?void 0:Mo.labelOnly)??!1,hn=((Po=H.debug)==null?void 0:Po.labelNoBg)??!1,Xn=jn&&l&&d?(()=>{const s=Qe(),u=Qe(),E=Ye(),_=Qe(),V=l.formatText(d,jn,{centered:!0,pixelScale:1/64,color:[1,1,1,1],outlinePx:2,outlineColor:[0,0,0,.85],backgroundColor:hn?[0,0,0,0]:[0,0,0,.35],backgroundPaddingPx:hn?0:6,backgroundRadiusPx:hn?0:6});return{render(q,Z){const te=Z.getProjectionMatrix(),oe=Z.getViewMatrix();l.updateCamera(te,oe),xs(s,oe)&&(wn(u,s),u[12]=0,u[13]=0,u[14]=0,u[15]=1,pi(E,Z.target),wn(_,u),_[12]=E[0],_[13]=E[1],_[14]=E[2],V.setTransform(_),l.render(q,V))}}})():null,fn=Xn?(s,u)=>Xn.render(s,u):null;P.disabled=ht===null,ht===null&&(P.checked=!1);const Le=ie?{xMin:ie.extent.xMin,xMax:ie.extent.xMax,yMin:c.min[1],yMax:c.max[1],zMin:ie.extent.zMin,zMax:ie.extent.zMax}:{xMin:c.min[0],xMax:c.max[0],yMin:c.min[1],yMax:c.max[1],zMin:c.min[2],zMax:c.max[2]},ft={xMin:Le.xMin,yMax:Le.yMax,zMax:Le.zMax},Ii={xMin:((wo=H.solids)==null?void 0:wo.cropX)!==void 0?Math.min(Math.max(Le.xMin,H.solids.cropX),Le.xMax):ft.xMin,yMax:((Io=H.solids)==null?void 0:Io.cropY)!==void 0?Math.min(Math.max(Le.yMin,H.solids.cropY),Le.yMax):ft.yMax,zMax:((So=H.solids)==null?void 0:So.cropZ)!==void 0?Math.min(Math.max(Le.zMin,H.solids.cropZ),Le.zMax):ft.zMax},G={mode:Be(),visibility:{terrain:y.checked,grid:b.checked,sections:v.checked,profiles:g.checked,solids:A.checked},sections:{displayMode:Ge()},solids:{enabled:yt,verticalSpacing:je(),displayMode:De(),highlightEdges:x.checked,showLabels:P.checked,crop:{...Ii}},selectedSectionId:null,selectedProfileId:null};document.body.dataset.mode=G.mode;const jt=s=>`${s.toFixed(2)} m`,Si=(s,u)=>{const E=Math.abs(u-s),_=.01;return!Number.isFinite(E)||E<=0?_:Math.max(_,E/400)},un=(s,u,E,_,V)=>{s.min=E.toString(),s.max=_.toString(),s.step=Si(E,_).toString(),s.value=V.toString(),u.textContent=jt(V)};un(S,B,Le.xMin,Le.xMax,G.solids.crop.xMin),un(T,R,Le.yMin,Le.yMax,G.solids.crop.yMax),un(k,W,Le.zMin,Le.zMax,G.solids.crop.zMax);const Wn=s=>Math.min(Math.max(Le.xMin,s),Le.xMax),qn=s=>Math.min(Math.max(Le.yMin,s),Le.yMax),$n=s=>Math.min(Math.max(Le.zMin,s),Le.zMax),Ti=()=>{const s=Number.parseFloat(S.value);return Number.isFinite(s)?Wn(s):ft.xMin},Ei=()=>{const s=Number.parseFloat(T.value);return Number.isFinite(s)?qn(s):ft.yMax},Ai=()=>{const s=Number.parseFloat(k.value);return Number.isFinite(s)?$n(s):ft.zMax},Ni=s=>{const u=Wn(s);S.value=u.toString(),G.solids.crop.xMin=u,Ht()},Ci=s=>{const u=qn(s);T.value=u.toString(),G.solids.crop.yMax=u,Ht()},zi=s=>{const u=$n(s);k.value=u.toString(),G.solids.crop.zMax=u,Ht()},_t=new Map,Xt=new Map;for(const s of o){if(s.objectType!=="solid"&&s.objectType!=="solidWireframe"&&s.objectType!=="solidEdge"||(_t.set(s.id,s.mesh),!s.soilId))continue;const u=Xt.get(s.soilId)??{};s.objectType==="solid"?u.solid=s:s.objectType==="solidEdge"?u.edges=s:u.wireframe=s,Xt.set(s.soilId,u)}const Ft=(s,u)=>{const E=_t.get(s.id);E&&s.mesh!==E&&s.mesh.vertexBuffer.destroy(),s.mesh=u},Fi=()=>{for(const s of Xt.values()){if(s.solid){const u=_t.get(s.solid.id);u&&Ft(s.solid,u)}if(s.wireframe){const u=_t.get(s.wireframe.id);u&&Ft(s.wireframe,u)}if(s.edges){const u=_t.get(s.edges.id);u&&Ft(s.edges,u)}}};let Hn="";const Wt=()=>{if(!(!ie||r!=null&&r.hasFailed()))try{const s=G.solids.crop.xMin,u=G.solids.crop.yMax,E=G.solids.crop.zMax,_=`${s.toFixed(5)}|${u.toFixed(5)}|${E.toFixed(5)}`;if(_===Hn)return;Hn=_;const V=s>ft.xMin+1e-4,q=E<ft.zMax-1e-4,Z=V||q,te=u<ft.yMax-1e-4;if(ct.clear(),!Z&&!te){const{verticesXZ:ge}=ie.mesh,fe=Math.floor(ge.length/2);for(const ve of ie.solids){const we=ie.surfaces[ve.top],xe=ie.surfaces[ve.bottom];!we||!xe||we.length!==fe||xe.length!==fe||ct.set(ve.soilId,{verticesXZ:ge,top:we,bottom:xe})}Fi();return}const{verticesXZ:oe,triangles:ye}=ie.mesh,me=Math.floor(oe.length/2);for(const ge of ie.solids){const fe=Xt.get(ge.soilId);if(!(fe!=null&&fe.solid)&&!(fe!=null&&fe.wireframe)&&!(fe!=null&&fe.edges))continue;const ve=ie.surfaces[ge.top],we=ie.surfaces[ge.bottom];if(!ve||!we||ve.length!==me||we.length!==me)continue;let xe=oe,Me=ye,Te=ve,K=we,Ee,Ae,Re;if(Z){if(V){const Fe=Tr(xe,Me,Te,K,s);xe=Fe.verticesXZ,Me=Fe.triangles,Te=Fe.top,K=Fe.bottom}if(q){const Fe=Sr(xe,Me,Te,K,Number.POSITIVE_INFINITY,E);xe=Fe.verticesXZ,Me=Fe.triangles,Te=Fe.top,K=Fe.bottom}}if(te){const Fe=Er(xe,Me,Te,K,u);xe=Fe.verticesXZ,Me=Fe.triangles,Re=Fe.boundaryTriangles,Te=Fe.top,K=Fe.bottom,Ee=Fe.topNormals,Ae=Fe.bottomNormals}const Oe=r?r.call("createTinVolumeMeshes",()=>Gn(e,xe,Me,Te,K,Ee,Ae,Re)):Gn(e,xe,Me,Te,K,Ee,Ae,Re);fe.solid&&Ft(fe.solid,Oe.solid),fe.wireframe&&Ft(fe.wireframe,Oe.wireframe),fe.edges&&Ft(fe.edges,Oe.edges),ct.set(ge.soilId,{verticesXZ:xe,top:Te,bottom:K})}}catch(s){r&&!r.hasFailed()&&r.fail("rebuildSolidsMeshes",s)}},qt=(s,u,E)=>[s[0]+(u[0]-s[0])*E,s[1]+(u[1]-s[1])*E,s[2]+(u[2]-s[2])*E,s[3]+(u[3]-s[3])*E],Kn=3,Bi=4,ki=.35,Li=.4,Ri=.6,_i=.35,Ui=.2,Qn=s=>{const u=qt(s,[1,1,1,s[3]],ki);return[u[0],u[1],u[2],Li]},Di=(s,u,E)=>{if(E==="wireframe"){s.color=u,s.material=[s.baseMaterial[0],Bi,s.baseMaterial[2],s.baseMaterial[3]];return}E==="transparent"?(s.color=Qn(u),s.material=[s.baseMaterial[0],Kn,s.baseMaterial[2],s.baseMaterial[3]]):(s.color=u,s.material=[...s.baseMaterial])},Gi=(s,u)=>{u==="transparent"?(s.color=Qn(s.baseColor),s.material=[0,Kn,s.baseMaterial[2],s.baseMaterial[3]]):(s.color=[...s.baseColor],s.material=[...s.baseMaterial])},Vi=(s,u)=>{if(u==="transparent"){const E=he==="light"?[0,0,0,s.baseColor[3]]:[1,1,1,s.baseColor[3]],_=he==="light"?_i:Ui,V=qt(s.baseColor,E,_);s.color=[V[0],V[1],V[2],Ri]}else s.color=s.baseColor},pn=()=>({min:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],max:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY]}),Bt=(s,u)=>{s.min[0]=Math.min(s.min[0],u.min[0]),s.min[1]=Math.min(s.min[1],u.min[1]),s.min[2]=Math.min(s.min[2],u.min[2]),s.max[0]=Math.max(s.max[0],u.max[0]),s.max[1]=Math.max(s.max[1],u.max[1]),s.max[2]=Math.max(s.max[2],u.max[2])},Oi=s=>Number.isFinite(s.min[0])&&Number.isFinite(s.min[1])&&Number.isFinite(s.min[2])&&Number.isFinite(s.max[0])&&Number.isFinite(s.max[1])&&Number.isFinite(s.max[2]),Yi=()=>{if(ie){const Z=$t.get("terrain");if(Z)return{min:[ie.extent.xMin,Z.min,ie.extent.zMin],max:[ie.extent.xMax,Z.max,ie.extent.zMax]}}const s=n.objects.find(Z=>Z.type==="terrain");if(!s)return null;const u=s.position??[0,0,0],E=s.scale??[1,1,1],_=s.mesh.size??[1,1,1],V=[E[0]*_[0],E[1]*_[1],E[2]*_[2]],q=[Math.abs(V[0])*.5,Math.abs(V[1])*.5,Math.abs(V[2])*.5];return{min:[u[0]-q[0],u[1]-q[1],u[2]-q[2]],max:[u[0]+q[0],u[1]+q[1],u[2]+q[2]]}},ji=()=>{const s=n.sections??[];if(s.length===0)return null;let u=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,_=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY,q=!1;for(const Z of s)for(const te of Z.path??[])u=Math.min(u,te[0]),E=Math.max(E,te[0]),_=Math.min(_,te[1]),V=Math.max(V,te[1]),q=!0;return q?{min:[u,c.min[1],_],max:[E,c.max[1],V]}:null},Xi=()=>{const s=n.profiles??[];if(s.length===0)return null;const E=.35*.5,_=.08,V=pn();let q=!1;for(const Z of s){const te=Z.position.x,oe=Z.position.y,ye=Z.position.zGround,me=Math.max(Z.depth,.01),ge=Math.max(E,_),fe={min:[te-ge,ye-me,oe-ge],max:[te+ge,ye+E,oe+ge]};Bt(V,fe),q=!0}return q?V:null},Wi=s=>{if(s.length===0)return null;let u=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY;for(const _ of s)Number.isFinite(_)&&(u=Math.min(u,_),E=Math.max(E,_));return!Number.isFinite(u)||!Number.isFinite(E)?null:{min:u,max:E}},$t=new Map;if(ie)for(const[s,u]of Object.entries(ie.surfaces)){const E=Wi(u);E&&$t.set(s,E)}const Zn=new Map;if(ie){const{extent:s}=ie;for(const u of ie.solids){const E=$t.get(u.top),_=$t.get(u.bottom),V=(_==null?void 0:_.min)??s.yBase,q=(E==null?void 0:E.max)??c.max[1];Zn.set(u.soilId,{min:[s.xMin,V,s.zMin],max:[s.xMax,q,s.zMax]})}}const Jn=Yi(),eo=ji(),to=Xi(),no=(s,u)=>{if(!Number.isFinite(u)||u===0)return 0;const E=tt*.5;return-(s-E)*u},qi=s=>{if(!ie)return null;const u=pn();let E=!1;for(const _ of ie.solids){if(!G.solids.enabled.has(_.soilId))continue;const V=Zn.get(_.soilId);if(!V)continue;const q=et.get(_.soilId)??0,Z=no(q,s),te=Math.max(V.min[0],G.solids.crop.xMin),oe=V.min[1],ye=V.min[2],me=V.max[0],ge=Math.min(V.max[1],G.solids.crop.yMax),fe=Math.min(V.max[2],G.solids.crop.zMax);me<te||ge<oe||fe<ye||(Bt(u,{min:[te,oe+Z,ye],max:[me,ge+Z,fe]}),E=!0)}return E?u:null},$i=()=>{if(!z)return{fracX:1,fracY:1,centerNdcX:0,centerNdcY:0};const s=Math.max(1,z.clientWidth),u=Math.max(1,z.clientHeight),E=16;if(window.matchMedia("(max-width: 720px)").matches)return{fracX:1,fracY:1,centerNdcX:0,centerNdcY:0};const V=z.getBoundingClientRect(),q=h.getBoundingClientRect(),Z=q.left-V.left,te=q.right-V.left,oe=q.top-V.top,ye=q.bottom-V.top,me=q.width>0&&q.height>0&&te>=0&&Z<=s&&ye>=0&&oe<=u,ge=E,fe=s-E,ve=E,we=u-E;let xe=fe,Me=ve;me&&(xe=Math.min(fe,Math.max(ge+1,Z-E))),Me>=we&&(Me=ve);const Te=Math.max(1,xe-ge),K=Math.max(1,we-Me),Ee=ge+Te*.5,Ae=Me+K*.5;return{fracX:Te/s,fracY:K/u,centerNdcX:2*Ee/s-1,centerNdcY:1-2*Ae/u}},mn=()=>{const s=pn();if(G.visibility.terrain&&Jn&&Bt(s,Jn),G.mode==="sections")G.visibility.sections&&eo&&Bt(s,eo),G.visibility.profiles&&to&&Bt(s,to);else if(G.visibility.solids){const u=qi(G.solids.verticalSpacing);u&&Bt(s,u)}return Oi(s)?s:c},gn=s=>{const u=$i(),E=Math.max(.05,Math.min(1,u.fracX)),_=Math.max(.05,Math.min(1,u.fracY)),V=1.1,q=(s.min[0]+s.max[0])*.5,Z=(s.min[1]+s.max[1])*.5,te=(s.min[2]+s.max[2])*.5,oe=s.max[0]-s.min[0],ye=s.max[1]-s.min[1],me=s.max[2]-s.min[2],ge=.5*Math.hypot(oe,ye,me)*V;if(!Number.isFinite(ge)||ge<=0){Ct(i.target,q,Z,te);return}Ct(i.target,q,Z,te);const fe=i.fov*.5,ve=Math.tan(fe),we=Xe(-Math.cos(i.pitch)*Math.cos(i.yaw),-Math.sin(i.pitch),-Math.cos(i.pitch)*Math.sin(i.yaw));at(we,we);const xe=Ye();xt(xe,we,Xe(0,1,0)),ui(xe)<1e-6?Ct(xe,1,0,0):at(xe,xe);const Me=Ye();xt(Me,xe,we),at(Me,Me);const Te=[[s.min[0],s.min[1],s.min[2]],[s.min[0],s.min[1],s.max[2]],[s.min[0],s.max[1],s.min[2]],[s.min[0],s.max[1],s.max[2]],[s.max[0],s.min[1],s.min[2]],[s.max[0],s.min[1],s.max[2]],[s.max[0],s.max[1],s.min[2]],[s.max[0],s.max[1],s.max[2]]];if(i.mode==="perspective"){const be=Math.max(1e-4,ve*i.aspect*E),Pe=Math.max(1e-4,ve*_);let $e=.2;const st=Ye();for(const He of Te){Ct(st,He[0]-q,He[1]-Z,He[2]-te);const Pt=mt(st,xe),wt=mt(st,Me),en=mt(st,we),Pn=Math.abs(Pt)*V/be-en,ds=Math.abs(wt)*V/Pe-en;$e=Math.max($e,Pn,ds)}i.distance=Math.min(200,Math.max(.2,$e))}else{let be=.2;const Pe=Ye(),$e=Math.max(1e-4,E*i.aspect),st=Math.max(1e-4,_);for(const He of Te){Ct(Pe,He[0]-q,He[1]-Z,He[2]-te);const Pt=mt(Pe,xe),wt=mt(Pe,Me),en=Math.abs(Pt)*V/$e,Pn=Math.abs(wt)*V/st;be=Math.max(be,en,Pn)}i.orthoScale=Math.min(200,Math.max(.2,be)),i.distance=i.orthoScale/Math.max(1e-4,ve)}let K=Number.POSITIVE_INFINITY,Ee=Number.NEGATIVE_INFINITY,Ae=Number.POSITIVE_INFINITY,Re=Number.NEGATIVE_INFINITY,Oe=0,Fe=0,qe=0,St=0;const Tt=Ye();Vt(Tt,i.target,we,-i.distance);for(const be of Te){const Pe=Xe(be[0]-Tt[0],be[1]-Tt[1],be[2]-Tt[2]),$e=mt(Pe,xe),st=mt(Pe,Me),He=Math.max(1e-4,mt(Pe,we)),Pt=i.mode==="perspective"?$e/(He*ve*i.aspect):$e/(i.orthoScale*i.aspect),wt=i.mode==="perspective"?st/(He*ve):st/i.orthoScale;Pt<K&&(K=Pt,Oe=He),Pt>Ee&&(Ee=Pt,Fe=He),wt<Ae&&(Ae=wt,qe=He),wt>Re&&(Re=wt,St=He)}const Qt=(K+Ee)*.5,Zt=(Ae+Re)*.5,Ut=u.centerNdcX-Qt,Dt=u.centerNdcY-Zt;let Et=0,At=0;if(i.mode==="perspective"){const be=1/Math.max(1e-4,Oe)+1/Math.max(1e-4,Fe),Pe=1/Math.max(1e-4,qe)+1/Math.max(1e-4,St),$e=be>1e-6?2/be:i.distance,st=Pe>1e-6?2/Pe:i.distance;Et=-Ut*(ve*i.aspect)*$e,At=-Dt*ve*st}else{const be=i.orthoScale,Pe=be*i.aspect;Et=-Ut*Pe,At=-Dt*be}if(Math.abs(Et)<1e-4&&Math.abs(At)<1e-4)return;const Nt=i.getPosition(),vt=Ye();Yn(vt,i.target,Nt),at(vt,vt);const Jt=Xe(0,1,0),Mt=Ye();xt(Mt,vt,Jt),at(Mt,Mt);const Ne=Ye();xt(Ne,Mt,vt),at(Ne,Ne),Vt(i.target,i.target,Mt,Et),Vt(i.target,i.target,Ne,At)},xn=new Map,Hi=new Map,Ki=new Map;let Qi=1;const oo=(s,u)=>{const E=s==="section"?Hi:Ki,_=E.get(u);if(_)return _;const V=Qi++;return E.set(u,V),xn.set(V,{type:s,id:u}),V},io=()=>{L.textContent=i.mode==="perspective"?"Perspective":"Orthographic"},so=()=>{X.textContent=`${G.solids.verticalSpacing.toFixed(2)} m`},Ht=()=>{B.textContent=jt(G.solids.crop.xMin),R.textContent=jt(G.solids.crop.yMax),W.textContent=jt(G.solids.crop.zMax)},ut=(s,u=3)=>Number.isFinite(s)?s.toFixed(u).replace(/\.?0+$/,""):"0",Zi=(s,u=3)=>{const E=[];for(let _=0;_<s.length;_+=1)E.push(ut(s[_],u));return E.join(",")};let ro="",ao=0;const Ji=150,es=()=>{const s=new URLSearchParams;if(s.set("theme",he),s.set("mode",G.mode),s.set("panelCollapsed",h.classList.contains("panel--collapsed")?"1":"0"),s.set("camMode",i.mode),s.set("camYawDeg",ut(i.yaw*180/Math.PI,3)),s.set("camPitchDeg",ut(i.pitch*180/Math.PI,3)),s.set("camDist",ut(i.distance,3)),s.set("camOrtho",ut(i.orthoScale,3)),s.set("camTarget",Zi(i.target,3)),s.set("terrain",G.visibility.terrain?"1":"0"),s.set("grid",G.visibility.grid?"1":"0"),s.set("sections",G.visibility.sections?"1":"0"),s.set("profiles",G.visibility.profiles?"1":"0"),s.set("solids",G.visibility.solids?"1":"0"),s.set("sectionsVis",G.sections.displayMode),s.set("solidsVis",G.solids.displayMode),s.set("solidsEdges",G.solids.highlightEdges?"1":"0"),s.set("solidsLabels",G.solids.showLabels?"1":"0"),s.set("solidsSpacing",ut(G.solids.verticalSpacing,3)),s.set("cropX",ut(G.solids.crop.xMin,3)),s.set("cropY",ut(G.solids.crop.yMax,3)),s.set("cropZ",ut(G.solids.crop.zMax,3)),ie){const u=ie.solids.map(_=>_.soilId),E=u.filter(_=>G.solids.enabled.has(_));E.length===u.length?s.set("solidsEnabled","*"):s.set("solidsEnabled",E.join(","))}return G.selectedSectionId&&s.set("section",G.selectedSectionId),G.selectedProfileId?s.set("profile",G.selectedProfileId):bt&&s.set("profile","none"),s.toString()},co=()=>{const s=performance.now();if(s-ao<Ji)return;ao=s;const u=es();if(u===ro)return;ro=u;const E=u.length>0?`${window.location.pathname}?${u}${window.location.hash}`:`${window.location.pathname}${window.location.hash}`;window.history.replaceState(null,"",E)},kt={terrain:y.checked,grid:b.checked,sections:v.checked},lo=s=>{s?(kt.terrain=y.checked,kt.grid=b.checked,kt.sections=v.checked,y.checked=!1,b.checked=!1,v.checked=!1,G.visibility.terrain=!1,G.visibility.grid=!1,G.visibility.sections=!1,y.disabled=!0,b.disabled=!0,v.disabled=!0):(y.disabled=!1,b.disabled=!1,v.disabled=!1,y.checked=kt.terrain,b.checked=kt.grid,v.checked=kt.sections,G.visibility.terrain=y.checked,G.visibility.grid=b.checked,G.visibility.sections=v.checked)},ze=()=>{const s=G.mode==="sections",u=G.mode==="solids",E=s&&G.visibility.sections,_=G.visibility.sections,V=s&&G.visibility.profiles,q=u&&G.visibility.solids,Z=G.sections.displayMode,te=G.solids.displayMode,oe=E&&Z==="wireframe",ye=q&&te==="wireframe",me=q&&G.solids.highlightEdges,ge=q&&G.solids.showLabels,fe=u?G.solids.verticalSpacing:0;le.style.display=u?"none":"",ae.style.display=u?"none":"",Y.style.display=u?"none":"",Q.style.display=s?"":"none",ne.style.display=u?"":"none";const ve=s?E:!!ie;N.style.opacity=ve?"1":"0.6",N.querySelectorAll("input[type='radio']").forEach(K=>{K.disabled=!ve}),D.style.opacity=V?"1":"0.6",D.querySelectorAll("input[type='radio']").forEach(K=>{K.disabled=!V}),U.style.opacity=q?"1":"0.6",U.querySelectorAll("input[type='checkbox']").forEach(K=>{K.disabled=!q});const we=[.678,1,.184,1],xe=[.43,.91,1,1],Me=[.678,1,.184,1];for(const K of o)if(K.objectType==="terrain"){const Ee=G.visibility.terrain,Ae=G.visibility.grid;K.visible=Ee||Ae,K.material[2]=Ae?K.baseMaterial[2]:0,K.material[3]=Ee?0:Ae?1:0}else if(K.objectType==="curve")K.visible=_;else if(K.objectType==="section"){K.visible=E;const Ae=G.selectedSectionId&&K.sectionId===G.selectedSectionId?qt(K.baseColor,we,.45):K.baseColor;Di(K,Ae,Z)}else if(K.objectType==="sectionWireframe"){K.visible=oe;const Ee=G.selectedSectionId&&K.sectionId===G.selectedSectionId;K.color=Ee?qt(K.baseColor,we,.45):K.baseColor}else if(K.objectType==="profile"){K.visible=V;const Ee=G.selectedProfileId&&K.profileId===G.selectedProfileId;K.color=Ee?Me:xe}else if(K.objectType==="solid"||K.objectType==="solidWireframe"||K.objectType==="solidEdge"){const Ee=K.soilId?G.solids.enabled.has(K.soilId):!0;K.objectType==="solid"?Gi(K,te):K.objectType==="solidEdge"&&Vi(K,te);const Ae=q&&te!=="wireframe";K.visible=(K.objectType==="solidWireframe"?ye:K.objectType==="solidEdge"?me:Ae)&&Ee,K.objectType==="solidEdge"&&(K.edgeXray=ye),wn(K.modelMatrix,K.baseMatrix),K.modelMatrix[13]+=no(K.layerIndex,fe)}else K.visible=!0;const Te=fn||(ge?ke:null);if(a.setOverlayRenderer(Te),fn&&wi)for(const K of o)K.visible=!1;vn()},ts={front:()=>({yaw:Math.PI/2,pitch:0}),back:()=>({yaw:-Math.PI/2,pitch:0}),left:()=>({yaw:Math.PI,pitch:0}),right:()=>({yaw:0,pitch:0}),top:()=>({yaw:i.yaw,pitch:Math.PI/2}),bottom:()=>({yaw:i.yaw,pitch:-Math.PI/2})};for(const s of F)s.addEventListener("click",()=>{const u=s.dataset.view??"",E=ts[u];if(!E)return;const{yaw:_,pitch:V}=E();i.setAngles(_,V),gn(mn())});const ns=()=>{G.mode=Be(),document.body.dataset.mode=G.mode,lo(G.mode==="solids"),G.mode==="sections"&&Ce(0),ze()};for(const s of w)s.addEventListener("change",ns);y.addEventListener("change",()=>{G.visibility.terrain=y.checked,ze()}),b.addEventListener("change",()=>{G.visibility.grid=b.checked,ze()}),v.addEventListener("change",()=>{G.visibility.sections=v.checked,ze()}),g.addEventListener("change",()=>{G.visibility.profiles=g.checked,ze()}),A.addEventListener("change",()=>{G.visibility.solids=A.checked,ze()});for(const s of M)s.addEventListener("change",()=>{s.checked&&(G.solids.displayMode=De(),ze())});for(const s of I)s.addEventListener("change",()=>{s.checked&&(G.sections.displayMode=Ge(),ze())});x.addEventListener("change",()=>{G.solids.highlightEdges=x.checked,ze()}),P.addEventListener("change",()=>{G.solids.showLabels=P.checked,ze()}),O.addEventListener("input",()=>{Ce(je()),ze()}),S.addEventListener("input",()=>{Ni(Ti()),Wt(),ze()}),T.addEventListener("input",()=>{Ci(Ei()),Wt(),ze()}),k.addEventListener("input",()=>{zi(Ai()),Wt(),ze()}),C.addEventListener("click",()=>{gn(mn())}),L.addEventListener("click",()=>{i.toggleProjection(),io()}),N.innerHTML="";const yn=new Map;if(n.sections&&n.sections.length>0)for(const s of n.sections){const u=document.createElement("label");u.className="panel-option";const E=document.createElement("input");E.type="radio",E.name="section-select",yn.set(s.id,E),E.addEventListener("change",()=>{E.checked&&(G.selectedSectionId=s.id,ze())}),u.appendChild(E),u.appendChild(document.createTextNode(s.name)),N.appendChild(u)}else{const s=document.createElement("div");s.className="panel-option",s.textContent="No sections loaded",N.appendChild(s)}D.innerHTML="";const bn=new Map;let bt=null;if(n.profiles&&n.profiles.length>0){const s=document.createElement("label");s.className="panel-option";const u=document.createElement("input");u.type="radio",u.name="profile-select",u.checked=!0,u.addEventListener("change",()=>{u.checked&&(G.selectedProfileId=null,ze())}),s.appendChild(u),s.appendChild(document.createTextNode("None")),D.appendChild(s),bt=u;for(const E of n.profiles){const _=document.createElement("label");_.className="panel-option";const V=document.createElement("input");V.type="radio",V.name="profile-select",bn.set(E.id,V),V.addEventListener("change",()=>{V.checked&&(G.selectedProfileId=E.id,ze())}),_.appendChild(V),_.appendChild(document.createTextNode(E.name)),D.appendChild(_)}}else{const s=document.createElement("div");s.className="panel-option",s.textContent="No profiles loaded",D.appendChild(s)}if(((To=H.selection)==null?void 0:To.sectionId)!==void 0){const s=H.selection.sectionId,u=yn.get(s);u&&(u.checked=!0,G.selectedSectionId=s)}if(((Eo=H.selection)==null?void 0:Eo.profileId)!==void 0){const s=H.selection.profileId;if(s===""||s==="none")bt&&(bt.checked=!0),G.selectedProfileId=null;else{const u=bn.get(s);u&&(u.checked=!0,G.selectedProfileId=s)}}const Kt=new Map;if(U.querySelectorAll("input[type='checkbox'][data-soil-id]").forEach(s=>{const u=s.dataset.soilId;u&&Kt.set(u,s)}),ie&&ie.solids.length>0){G.solids.enabled.clear();for(const s of ie.solids){let u=Kt.get(s.soilId);if(!u){const E=document.createElement("label");E.className="panel-option",u=document.createElement("input"),u.type="checkbox",u.checked=!0,u.dataset.soilId=s.soilId,Kt.set(s.soilId,u),E.appendChild(u),E.appendChild(document.createTextNode(s.name)),U.appendChild(E)}u.checked&&G.solids.enabled.add(s.soilId),u.addEventListener("change",()=>{u.checked?G.solids.enabled.add(s.soilId):G.solids.enabled.delete(s.soilId),ze()})}if(((Ao=H.solids)==null?void 0:Ao.enabled)!==void 0){const s=new Set(H.solids.enabled),u=s.has("*")||s.has("all");G.solids.enabled.clear();for(const E of ie.solids){const _=Kt.get(E.soilId);if(!_)continue;const V=u||s.has(E.soilId);_.checked=V,V&&G.solids.enabled.add(E.soilId)}}U.style.visibility="",A.disabled=!1,M.forEach(s=>{s.disabled=!1}),x.disabled=!1,P.disabled=ht===null,O.disabled=!1,S.disabled=!1,T.disabled=!1,k.disabled=!1}else{const s=document.createElement("div");s.className="panel-option",s.textContent="No solids model loaded",U.appendChild(s),U.querySelectorAll("input[type='checkbox']").forEach(u=>{u.disabled=!0}),U.style.visibility="",A.checked=!1,A.disabled=!0,M.forEach(u=>{u.disabled=!0,u.value==="classic"&&(u.checked=!0)}),x.checked=!1,x.disabled=!0,P.checked=!1,P.disabled=!0,G.solids.showLabels=!1,O.disabled=!0,S.disabled=!0,T.disabled=!0,k.disabled=!0,G.visibility.solids=!1}so(),Ht();const os=pe(),is=H.theme??os,ho=m.find(s=>s.value===is);ho&&(ho.checked=!0),Ie(Se());for(const s of m)s.addEventListener("change",()=>{s.checked&&(Ie(Se()),ze())});(No=H.camera)!=null&&No.mode&&(i.mode=H.camera.mode),(((Co=H.camera)==null?void 0:Co.yaw)!==void 0||((zo=H.camera)==null?void 0:zo.pitch)!==void 0)&&i.setAngles(H.camera.yaw??i.yaw,H.camera.pitch??i.pitch),io(),lo(G.mode==="solids"),Wt(),ze(),co(),((Fo=H.camera)==null?void 0:Fo.target)!==void 0||((Bo=H.camera)==null?void 0:Bo.distance)!==void 0||((ko=H.camera)==null?void 0:ko.orthoScale)!==void 0||gn(mn()),(Lo=H.camera)!=null&&Lo.target&&Ct(i.target,H.camera.target[0],H.camera.target[1],H.camera.target[2]),((Ro=H.camera)==null?void 0:Ro.distance)!==void 0&&(i.distance=H.camera.distance),((_o=H.camera)==null?void 0:_o.orthoScale)!==void 0&&(i.orthoScale=H.camera.orthoScale);for(const s of o)s.objectType==="section"&&s.sectionId?s.pickId=oo("section",s.sectionId):s.objectType==="profile"&&s.profileId?s.pickId=oo("profile",s.profileId):s.pickId=0;z&&z.addEventListener("click",async s=>{if(s.button!==0||r!=null&&r.hasFailed()||G.mode==="solids")return;const u=z.getBoundingClientRect(),E=s.clientX-u.left,_=s.clientY-u.top;let V=null;try{V=r?await r.callAsync("Renderer.pick",()=>a.pick(E,_)):await a.pick(E,_)}catch{return}if(!V||!xn.has(V)){bt&&(bt.checked=!0),G.selectedSectionId=null,G.selectedProfileId=null,ze();return}const q=xn.get(V);if(q){if(q.type==="section"){G.selectedSectionId=q.id,G.selectedProfileId=null;const Z=yn.get(q.id);Z&&(Z.checked=!0),bt&&(bt.checked=!0),v.checked||(v.checked=!0,G.visibility.sections=!0)}else if(q.type==="profile"){G.selectedProfileId=q.id,G.selectedSectionId=null;const Z=bn.get(q.id);Z&&(Z.checked=!0),g.checked||(g.checked=!0,G.visibility.profiles=!0)}ze()}}),Ze.addEventListener("click",()=>{G.selectedSectionId=null,ze()}),window.addEventListener("resize",()=>{vn()});function vn(){const s=G.selectedSectionId,u=!!(s&&(G.mode==="sections"&&G.visibility.sections||G.mode==="solids"&&ie));if(it.classList.toggle("visible",!!u),!u||!s)return;const E=zt.get(s);if(!E)return;Ue.textContent=E.name;const _=Ve.getContext("2d");if(!_)return;const V=window.devicePixelRatio||1,q=Math.max(1,Ve.clientWidth),Z=Math.max(1,Ve.clientHeight);Ve.width=Math.floor(q*V),Ve.height=Math.floor(Z*V),_.setTransform(V,0,0,V,0,0),_.clearRect(0,0,q,Z),_.fillStyle=ee.sectionCanvasBg,_.fillRect(0,0,q,Z);const te=G.mode==="solids"?ie?Br(E,ie):null:E.vector?ss(E.vector):null;if(!te||te.patches.length===0){_.fillStyle=ee.sectionEmptyText,_.font="12px IBM Plex Sans, sans-serif",_.fillText("No polygons available for this section.",16,24);return}const oe={left:50,right:20,top:24,bottom:28},ye=Math.max(1,q-oe.left-oe.right),me=Math.max(1,Z-oe.top-oe.bottom),ge=ye/Math.max(te.maxS-te.minS,.01),fe=me/Math.max(te.maxD-te.minD,.01),ve=xe=>oe.left+(xe-te.minS)*ge,we=xe=>oe.top+(xe-te.minD)*fe;_.strokeStyle=ee.sectionAxis,_.lineWidth=1,_.beginPath(),_.moveTo(oe.left,oe.top),_.lineTo(oe.left,oe.top+me),_.lineTo(oe.left+ye,oe.top+me),_.stroke(),rs(_,oe.left,oe.top,me,te.minD,te.maxD,ee);for(const xe of te.patches){const Me=Je.get(xe.soilId),Te=(Me==null?void 0:Me.color)??[.6,.6,.6],K=(Me==null?void 0:Me.patternId)??0,Ee=`rgb(${Math.round(Te[0]*255)}, ${Math.round(Te[1]*255)}, ${Math.round(Te[2]*255)})`;for(const Ae of xe.rings){if(Ae.length===0)continue;const Re=Ae.map(Oe=>({x:ve(Oe.s),y:we(Oe.d)}));_.beginPath(),_.moveTo(Re[0].x,Re[0].y);for(let Oe=1;Oe<Re.length;Oe+=1)_.lineTo(Re[Oe].x,Re[Oe].y);_.closePath(),_.fillStyle=Ee,_.fill(),as(_,Re,K),_.strokeStyle=ee.sectionPatchStroke,_.lineWidth=.75,_.stroke()}}}function ss(s){const u=[];let E=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,V=Number.POSITIVE_INFINITY,q=Number.NEGATIVE_INFINITY;for(const[Z,te]of Object.entries(s.patches)){const oe=[];for(const ye of te.rings){const me=ye.map(([ge,fe])=>{const ve=ge*s.sScale,we=s.zRef-fe;return E=Math.min(E,ve),_=Math.max(_,ve),V=Math.min(V,we),q=Math.max(q,we),{s:ve,d:we}});oe.push(me)}u.push({soilId:Z,rings:oe})}return!Number.isFinite(E)||!Number.isFinite(V)?null:{minS:E,maxS:_,minD:V,maxD:q,patches:u}}function rs(s,u,E,_,V,q,Z){const te=Math.max(.1,q-V),oe=te/5,ye=[.5,1,2,5,10];let me=ye[0];for(const ge of ye)oe>ge&&(me=ge);s.font="11px IBM Plex Sans, sans-serif",s.fillStyle=Z.sectionText,s.textAlign="right",s.textBaseline="middle";for(let ge=V;ge<=q+.001;ge+=me){const fe=E+(ge-V)/te*_;s.strokeStyle=Z.sectionAxisTick,s.beginPath(),s.moveTo(u,fe),s.lineTo(u-6,fe),s.stroke(),s.fillText(ge.toFixed(1),u-8,fe)}}function as(s,u,E){if(E===0||u.length===0)return;let _=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY,q=Number.POSITIVE_INFINITY,Z=Number.NEGATIVE_INFINITY;for(const oe of u)_=Math.min(_,oe.x),V=Math.max(V,oe.x),q=Math.min(q,oe.y),Z=Math.max(Z,oe.y);const te={x:_,y:q,width:Math.max(1,V-_),height:Math.max(1,Z-q)};s.save(),s.beginPath(),s.moveTo(u[0].x,u[0].y);for(let oe=1;oe<u.length;oe+=1)s.lineTo(u[oe].x,u[oe].y);s.closePath(),s.clip(),s.strokeStyle=ee.sectionHatch,s.lineWidth=1,E===1?(s.lineWidth=.25,Mn(s,te,Math.PI/4,12),Mn(s,te,-Math.PI/4,12)):E===2?(s.lineWidth=.25,cs(s,te,Math.PI/4,9,8,2)):E===3&&(s.lineWidth=.25,ls(s,te)),s.restore()}function Mn(s,u,E,_){const V=u.x+u.width*.5,q=u.y+u.height*.5,Z=Math.hypot(u.width,u.height);s.save(),s.translate(V,q),s.rotate(E),s.translate(-V,-q);const te=V-Z,oe=V+Z;for(let ye=te;ye<=oe;ye+=_)s.beginPath(),s.moveTo(ye,q-Z),s.lineTo(ye,q+Z),s.stroke();s.restore()}function cs(s,u,E,_,V,q){s.save(),s.setLineDash([V,q]),Mn(s,u,E,_),s.restore()}function ls(s,u){const Z=Math.ceil(u.height/9)+1;for(let te=0;te<Z;te+=1){const oe=u.y+te*9,ye=te%3*12;for(let me=u.x-36;me<=u.x+u.width+36;me+=36)s.beginPath(),s.moveTo(me+ye,oe),s.lineTo(me+ye+12.5,oe),s.stroke()}}return co}ua().catch(e=>{console.error(e),Ke.hasFailed()||da(e instanceof Error?e.message:String(e))});
